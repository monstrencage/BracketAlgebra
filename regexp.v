(** * RIS.regexp : regular expressions and the free Kleene algebra. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Require Import tools algebra language.
Require Import Bool.
Section regexp.
  Context {X : Set}.
  (** * Definitions *)
  (** Regular expressions are terms generated by the following syntax. *)
  Inductive regexp : Set :=
  | e_zero : regexp
  | e_un : regexp
  | e_add : regexp -> regexp -> regexp
  | e_prod : regexp -> regexp -> regexp
  | e_star : regexp -> regexp
  | atomic : X -> regexp.

  Notation " ⟪ l ⟫" := (atomic l).

  (** The size of an expression is the number of occurrences of variables appearing in it. *)
  Fixpoint sizeExpr e :=
    match e with
    | e_un | e_zero => 0
    | ⟪_⟫ => 1
    | e_add e f | e_prod e f => sizeExpr e + sizeExpr f
    | e_star e => sizeExpr e
    end.

  (** We may associate to an expression [e] the regular language [⟦e⟧]. *)
  Reserved Notation " ⟦ e ⟧ ".
  Fixpoint reg_lang (e : regexp) : language :=
    match e with
    | e_un => 𝟭
    | e_zero => 𝟬
    | e_prod e f => ⟦e⟧ · ⟦f⟧
    | e_add e f => ⟦e⟧ ∪ ⟦f⟧
    | e_star e => ⟦e⟧ ⋆
    | ⟪ l ⟫ => fun w => w = [l]
    end
  where " ⟦ e ⟧ " := (reg_lang e).

  (* begin hide *)
  Global Instance regUn : Un regexp := e_un.

  Global Instance regZero : Zero regexp :=e_zero.

  Global Instance regJoin : Join regexp := e_add.

  Global Instance regProduct : Product regexp :=e_prod.

  Global Instance regStar : Star regexp := e_star.
  (* end hide *)

  (** Given a set of identities [Ax] (i.e. a binary relation over
  expressions) and a set of quasi-equations [Ax'] (i.e. a quaternary
  relation), we define the relation [{| Ax , Ax' |} ⊢ e == f] as the
  smallest congruence stable by both [Ax] and [Ax']. *)
  Reserved Notation " {| Ax , Ax' |} ⊢ e == f " (at level 80).
  Inductive ax_eq (Ax : relation regexp) (Ax' : regexp -> regexp -> regexp -> regexp -> Prop)
    : relation regexp :=
  | ax_eq_refl e : {|Ax,Ax'|} ⊢ e == e
  | ax_eq_sym e f : {|Ax,Ax'|} ⊢ e == f -> {|Ax,Ax'|} ⊢ f == e
  | ax_eq_trans e f g : {|Ax,Ax'|} ⊢ e == f -> {|Ax,Ax'|} ⊢ f == g -> {|Ax,Ax'|} ⊢ e == g 
  | ax_eq_prod e f e' f' : {|Ax,Ax'|} ⊢ e == f -> {|Ax,Ax'|} ⊢ e' == f' -> {|Ax,Ax'|} ⊢ e · e' == f · f'
  | ax_eq_add e f e' f' : {|Ax,Ax'|} ⊢ e == f -> {|Ax,Ax'|} ⊢ e' == f' -> {|Ax,Ax'|} ⊢ e ∪ e' == f ∪ f'
  | ax_eq_star e f : {|Ax,Ax'|} ⊢ e == f -> {|Ax,Ax'|} ⊢ e ⋆ == f ⋆
  | ax_eq_ax e f : Ax e f -> {|Ax,Ax'|} ⊢ e == f
  | ax_eq_ax' e f g h : Ax' e f g h -> {|Ax,Ax'|} ⊢ e == f -> {|Ax,Ax'|} ⊢ g == h
  where " {| Ax , Ax' |} ⊢ e == f " := (ax_eq Ax Ax' e f).

  Definition ax_inf Ax Ax' e f := {|Ax,Ax'|} ⊢ e ∪ f == f.
  Notation " {| Ax , Ax' |} ⊢ e =<= f " := (ax_inf Ax Ax' e f) (at level 80).
  
  Hint Constructors ax_eq.

  (** * Basic properties *)
  (** ** Properties of the language interpretation *)
  Lemma Σ_lang L u : ⟦Σ L⟧ u <-> exists e, e ∈ L /\ ⟦e⟧ u.
  Proof.
    revert u;induction L;intros;simpl.
    - split;[intro F;exfalso;apply F|intros (?&?&_);tauto].
    - split.
      + intros [I|I].
        * exists a;tauto.
        * apply IHL in I as (e&Ie&Iu);exists e;tauto.
      + intros (e&[<-|Ie]&Iu);[left|right;apply IHL;exists e];tauto.
  Qed.

  Lemma split_star e u v :
    ⟦e⋆⟧ (u++v) ->
    (u=[] /\ v=[])
    \/ exists u1 u2 v1 v2, u = u1++u2 /\ v=v1++v2 /\ ⟦e⋆⟧ u1 /\ ⟦e⟧ (u2++v1) /\ ⟦e⋆⟧ v2.
  Proof.
    intros (n&In);revert u v In;induction n;intros u v;simpl.
    - intro E;apply app_eq_nil in E as (->&->);tauto.
    - intros (w1&w2&E&I1&I2);right.
      levi E;subst;clear E.
      + exists [],w1,[],w2;repeat split.
        * exists 0;reflexivity.
        * rewrite app_nil_r;assumption.
        * exists n;assumption.
      + apply (IHn (a::w) v) in I2 as [(F&_)|(u1&u2&v1&v2&E1&->&h1&h2&h3)];
          [discriminate|].
        replace (cons a) with (app [a]) in * by reflexivity.
        rewrite E1 in *;clear E1 a w.
        exists (w1++u1),u2,v1,v2;rewrite app_ass;repeat split;try assumption.
        destruct h1 as (N&I).
        exists (S N),w1,u1;tauto.
      + clear IHn.
        exists [],u,(a::w),w2;repeat split.
        * exists 0;reflexivity.
        * assumption.
        * exists n;assumption.
  Qed.

  (** ** Properties of the axiomatic equivalence *)  
  Global Instance ax_eq_Equivalence Ax Ax' : Equivalence (ax_eq Ax Ax').
  Proof.
    split.
    - intro e;auto.
    - intros e f;eauto.
    - intros e f g E1 E2;eauto.
  Qed.

  Global Instance prod_ax_eq Ax Ax' :
    Proper (ax_eq Ax Ax' ==> ax_eq Ax Ax' ==> ax_eq Ax Ax') prod.
  Proof. intros ? ? ? ? ? ?;eauto. Qed.

  Global Instance join_ax_eq Ax Ax' :
    Proper (ax_eq Ax Ax' ==> ax_eq Ax Ax' ==> ax_eq Ax Ax') join.
  Proof. intros ? ? ? ? ? ?;eauto. Qed.

  Global Instance star_ax_eq Ax Ax':
    Proper (ax_eq Ax Ax'==> ax_eq Ax Ax') star.
  Proof. intros ? ? ?;eauto. Qed.

  (** If the axioms [Ax,Ax'] are sound with respect to the language
  interpretation, so is the relation [{|Ax,Ax'|}⊢_==_]. *)
  Remark soundness_proof (Ax: relation regexp)(Ax' : regexp -> regexp -> regexp -> regexp -> Prop):
    (forall e f, Ax e f -> ⟦e⟧ ≃ ⟦f⟧) ->
    (forall e f g h, Ax' e f g h -> ⟦e⟧ ≃ ⟦f⟧ -> ⟦g⟧ ≃ ⟦h⟧) ->
    forall e f, {|Ax,Ax'|} ⊢ e == f -> ⟦e⟧ ≃ ⟦f⟧.
  Proof.
    intros hyp1 hyp2 e f E;induction E.
    - reflexivity.
    - symmetry;assumption.
    - etransitivity;eassumption.
    - simpl;rewrite IHE1,IHE2;reflexivity.
    - simpl;rewrite IHE1,IHE2;reflexivity.
    - simpl;rewrite IHE;reflexivity.
    - apply hyp1;assumption.
    - eapply hyp2;eassumption.
  Qed.

  Section gen_proofs.
    Context {Ax : relation regexp}{Ax' : regexp -> regexp -> regexp -> regexp -> Prop}.

    (** A set of axioms is good enough if it entails that [∪] is
    idempotent, associative and commutative. *)
    Class GoodEnoughAxiom Ax :=
      {join_idem : forall e, Ax (e ∪ e) e;
       join_assoc : forall e f g, Ax (e ∪ (f ∪ g)) ((e ∪ f) ∪ g);
       join_comm : forall e f, Ax (e ∪ f) (f ∪ e)}.

    Context {G : GoodEnoughAxiom Ax}.

    (** In this case, we can show that [{|Ax,Ax'|} ⊢ e =<= f] is a
    partial order, thus yielding a semi-lattice structure. *)
    Global Instance ax_inf_PreOrder : PreOrder (fun e f => {|Ax,Ax'|} ⊢ e =<= f).
    Proof.
      destruct G as [h1 h2 h3];split.
      - intro e;apply ax_eq_ax;auto.
      - intros e f g E1 E2.
        unfold ax_inf in *.
        etransitivity;[|apply E2].
        rewrite <- E1;rewrite <- E2 at 1;apply ax_eq_ax;auto.
    Qed.

    Global Instance ax_inf_PartialOrder :
      PartialOrder (ax_eq Ax Ax') (fun e f => {|Ax,Ax'|} ⊢ e =<= f).
    Proof.
      destruct G as [h1 h2 h3];intros e f;split;unfold Basics.flip,ax_inf.
      - intro E;split.
        + rewrite E;auto.
        + rewrite E;auto.
      - intros (E1&E2).
        rewrite <- E1.
        rewrite <- E2 at 1;auto.
    Qed.
    
    Global Instance joinOrder_ax : JoinOrder _ (ax_eq Ax Ax') (ax_inf Ax Ax') join.
    Proof. intros x y;unfold ax_inf;split;intro h;symmetry;apply h. Qed.

    Lemma ax_eq_inf e f : {| Ax,Ax'|} ⊢ e == f -> {| Ax,Ax'|} ⊢ e =<= f.
    Proof. rewrite (ax_inf_PartialOrder e f);intros (H&_);tauto. Qed.

    Global Instance Semilattice_ax : Semilattice _ (ax_eq Ax Ax') join.
    Proof.
      split.
      - intros e f g;apply ax_eq_ax,join_assoc.
      - intros e f;apply ax_eq_ax,join_comm.
      - intro e;apply ax_eq_ax,join_idem.
    Qed.

    (** [Ax] is very good if in addition it entails distributivity of
    [·] over [∪]. *)
    Class VeryGoodAxioms Ax :=
      {left_distr : forall e f g, Ax (e · (f ∪ g))  (e·f ∪ e·g);
       right_distr : forall e f g, Ax ((e ∪ f)· g) (e·g ∪ f·g)}.

    Context {V : VeryGoodAxioms Ax}.

    (** In this case, the product preserves the ordering. *)
    Global Instance prod_ax_inf :
      Proper (ax_inf Ax Ax' ==> ax_inf Ax Ax' ==> ax_inf Ax Ax') prod.
    Proof.
      destruct V as (h1&h2);destruct G as [h3 h4 h5];intros e1 e2 E1 f1 f2 E2;unfold ax_inf in *.
      rewrite <-E2 at 2.
      transitivity (e2 · f1 ∪ e2 · f2);[|now auto].
      rewrite <- E1 at 2.
      transitivity ((e1 · f1 ∪ e2 · f1) ∪ e2 · f2);[|now auto].
      transitivity (e1 · f1 ∪ (e2 · f1 ∪ e2 · f2));[|now auto].
      transitivity (e1 · f1 ∪ e2 · (f1 ∪ f2));[|now auto].
      rewrite E2;reflexivity.
    Qed.

  End gen_proofs.

  (** * The axiomatization [KA]. *)
  Reserved Notation " e =KA f " (at level 80).
  Reserved Notation " e <=KA f " (at level 80).
  
  Inductive KA : relation regexp :=
  | KA_prod_assoc e f g : e · (f · g) =KA (e · f) · g
  | KA_add_assoc e f g : e ∪ (f ∪ g) =KA (e ∪ f) ∪ g
  | KA_add_comm e f : e ∪ f =KA f ∪ e
  | KA_left_distr e f g : e · (f ∪ g) =KA e·f ∪ e·g
  | KA_right_distr e f g : (e ∪ f)· g =KA e·g ∪ f·g
  | KA_zero e : 𝟬 <=KA e
  | KA_un_left e : 𝟭 · e =KA e
  | KA_un_right e : e · 𝟭 =KA e
  | KA_left_zero e : 𝟬 · e =KA 𝟬
  | KA_right_zero e : e · 𝟬 =KA 𝟬
  | KA_idem e : e <=KA e
  | KA_star_unfold e : 𝟭 ∪ e · e ⋆ <=KA e⋆ 
  where " e =KA f " := (KA e f)
  and " e <=KA f " := (KA (e ∪ f) f).

  Hint Constructors KA.

  Inductive KA' : regexp -> regexp -> regexp -> regexp -> Prop :=
  | KA_star_left_ind e f : KA' (e · f ∪ f) f (e ⋆ · f ∪ f) f
  | KA_star_right_ind e f : KA' (e · f ∪ e) e (e · f ⋆ ∪ e) e.

  Hint Constructors KA'.
  
  Global Instance goodKA : GoodEnoughAxiom KA.
  Proof. split;intros;auto. Qed.
  Global Instance verygoodKA : VeryGoodAxioms KA.
  Proof. split;intros;auto. Qed.
  
  Lemma star_left_ind e f : {| KA,KA'|} ⊢ e · f =<= f -> {| KA,KA'|} ⊢ e⋆ · f =<= f.
  Proof.
    intro h;eapply ax_eq_ax'.
    - apply KA_star_left_ind.
    - apply h.
  Qed.
  Lemma star_right_ind e f : {| KA,KA'|} ⊢ e · f =<= e -> {| KA,KA'|} ⊢ e · f⋆ =<= e.
  Proof.
    intro h;eapply ax_eq_ax'.
    - apply KA_star_right_ind.
    - apply h.
  Qed.

  (** The set of expressions equipped with the axioms [KA,KA'] forms a Kleene algebra. *)
  Global Instance KA_regexp : KleeneAlgebra regexp (ax_eq KA KA') (ax_inf KA KA').
  Proof.
    split.
    - apply prod_ax_eq.
    - apply join_ax_eq.
    - apply star_ax_eq.
    - repeat split;intro;intros;eauto.
    - repeat split;intro;intros;eauto.
    - apply joinOrder_ax.
    - intros a;apply ax_eq_ax;auto.
    - apply star_left_ind. 
    - apply star_right_ind.
  Qed.
  Global Instance Semilattice_KA : Semilattice _ (ax_eq KA KA') join := join_semilattice.

  (** Axiomatic equivalence is sound with respect to the language interpretation. *)
  Proposition soundness e f : {|KA,KA'|} ⊢ e == f -> ⟦e⟧ ≃ ⟦f⟧.
  Proof.
    apply soundness_proof;clear.
    - intros e f E;destruct E;simpl;try now apply lang_KA.
      + apply mon_assoc.
      + apply mon_assoc.
      + apply semiring_comm.
      + symmetry;apply join_is_order,ka_star_unfold.
    - intros e f g h E;destruct E;intro E;simpl in *;symmetry in E;
        rewrite <- join_is_order in E;symmetry;apply join_is_order.
      + apply ka_star_left_ind,E.
      + apply ka_star_right_ind,E.
  Qed.
  
  Lemma ax_inf_lang_incl e f : {| KA,KA' |} ⊢ e =<= f -> ⟦e⟧ ≲ ⟦f⟧.
  Proof.
    unfold ax_inf;rewrite join_is_order;intro I.
    transitivity ⟦e∪f⟧;[|reflexivity].
    apply soundness;symmetry;assumption.
  Qed.

  (** * Equatity modulo associativity, commutativity, idempotence and units. *)
  Inductive ACI0 : relation regexp :=
  | ACI0_prod_assoc e f g : ACI0(e · (f · g)) ((e · f) · g)
  | ACI0_add_assoc e f g : ACI0 (e ∪ (f ∪ g)) ((e ∪ f) ∪ g)
  | ACI0_add_comm e f : ACI0 (e ∪ f) (f ∪ e)
  | ACI0_add_idem e : ACI0 (e ∪ e) e
  | ACI0_add_zero e : ACI0 (e ∪ 𝟬) e
  | ACI0_prod_one e : ACI0 (𝟭 · e) e.
  Definition Empt : regexp -> regexp -> regexp -> regexp -> Prop := fun _ _ _ _ => False.
  Hint Constructors ACI0.

  Global Instance goodACI0 : GoodEnoughAxiom ACI0.
  Proof. split;intros;auto. Qed.

  Infix " ≡0 " := (ax_eq ACI0 Empt) (at level 80).
  Infix " ≦0 " := (ax_inf ACI0 Empt) (at level 80).
  
  Lemma KA_ACI0 e f : e ≡0 f -> {|KA,KA'|}⊢e==f.
  Proof.
    intros E;induction E.
    - reflexivity.
    - symmetry;assumption.
    - etransitivity;eassumption.
    - rewrite IHE1,IHE2;reflexivity.
    - rewrite IHE1,IHE2;reflexivity.
    - rewrite IHE;reflexivity.
    - destruct H;auto.
      transitivity (𝟬∪e);auto.
    - destruct H.
  Qed.
  
  (** * Utilities *)
  (** ** Variables *)
  (** [Var e] computes the set of variables appearing in [e]. *)
  Fixpoint Var (e : regexp) : list X :=
    match e with
    | e_un | e_zero => []
    | ⟪x⟫ => [x]
    | e_prod e f | e_add e f => Var e ++ Var f
    | e_star e => Var e
    end.

  Lemma Var_spec e w : ⟦ e ⟧ w -> w ⊆ Var e.
  Proof.
    revert w;induction e;intro w;simpl.
    - intro I;exfalso;apply I.
    - intros ->;reflexivity.
    - intros [I|I].
      + rewrite IHe1 by assumption;apply incl_appl;reflexivity.
      + rewrite IHe2 by assumption;apply incl_appr;reflexivity.
    - intros (u&v&->&Iu&Iv).
      apply IHe1 in Iu as ->.
      apply IHe2 in Iv as ->.
      reflexivity.
    - intros (n&I);revert w I;induction n.
      + intros w ->;apply incl_nil.
      + intros w (u&v&->&I1&I2).
        apply IHe in I1 as ->.
        apply IHn in I2 as ->.
        intro;simpl_In;tauto.
    - intros ->;reflexivity.
  Qed.

  (** ** Empty word *)
  (** [ϵ e] yields [𝟭] if [⟦e⟧] contains the empty word, [𝟬] otherwise. *)
  Fixpoint ϵ (e : regexp) : regexp :=
    match e with
    | e_un | e_star _ => e_un
    | e_zero | ⟪_⟫ => e_zero
    | e_prod e f =>
      match (ϵ e,ϵ f) with
      | (e_un,e_un) => e_un
      | _ => e_zero
      end
    | e_add e f => 
      match (ϵ e,ϵ f) with
      | (e_un,_) | (_,e_un) => e_un
      | _ => e_zero
      end
    end.

  Lemma nil_prod_lang (l m : @language X) : (l·m) [] <-> l [] /\ m [].
  Proof.
    split.
    - intros (u&v&e&h);symmetry in e;apply app_eq_nil in e as (->&->);assumption.
    - intros h;exists [],[];split;[reflexivity|assumption].
  Qed.

  Lemma ϵ_zero_or_un e : {ϵ e = e_un} + {ϵ e = e_zero}.
  Proof.
    induction e;simpl;try tauto.
    - destruct IHe1 as [-> | ->] ;[|destruct IHe2 as [-> | ->]];tauto.
    - destruct IHe1 as [-> | ->] ;[destruct IHe2 as [-> | ->]|];tauto.
  Qed.
  
  Lemma ϵ_spec e : ϵ e = e_un <-> ⟦e⟧ [].
  Proof.
    induction e;simpl.
    - split;[discriminate|intro F;exfalso;apply F].
    - split;reflexivity.
    - destruct (ϵ e1);tauto || destruct (ϵ e2);
        try (split;[discriminate|intros [h|h];apply IHe1 in h||apply IHe2 in h;discriminate]);
        try (split;[intros _;(left;apply IHe1;reflexivity)
                             ||(right;apply IHe2;reflexivity)
                   |reflexivity]).
    - etransitivity;[|symmetry;apply nil_prod_lang].
      rewrite <- IHe1,<-IHe2;clear.
      split.
      + destruct (ϵ e1);tauto || destruct (ϵ e2);discriminate||tauto.
      + intros (-> & ->);reflexivity.
    - split;[|reflexivity].
      intros _;exists 0;reflexivity.
    - split;discriminate.
  Qed.

  Lemma ϵ_inf_e e : {|KA,KA'|} ⊢ ϵ e =<= e.
  Proof.
    induction e;simpl.
    - reflexivity.
    - reflexivity.
    - replace e_add with join by reflexivity.
      transitivity (ϵ e1 ∪ ϵ e2);[clear IHe1 IHe2|rewrite IHe1,IHe2;reflexivity].
      apply ax_eq_inf.
      destruct (ϵ_zero_or_un e1) as [-> | ->]; try destruct (ϵ_zero_or_un e2)as [-> | ->];eauto.
    - replace e_prod with prod by reflexivity.
      transitivity (ϵ e1 · ϵ e2);[clear IHe1 IHe2|rewrite IHe1,IHe2;reflexivity].
      apply ax_eq_inf.
      destruct (ϵ_zero_or_un e1) as [-> | ->]; try destruct (ϵ_zero_or_un e2)as [-> | ->];eauto.
    - apply one_inf_star.
    - replace e_zero with zero by reflexivity;apply zero_minimal.
  Qed.

  (** [ϵ e] is [𝟭] exactly when the inequation [𝟭<=e] is provable in [KA]. *)
  Lemma ϵ_ax_spec e : ϵ e = un <-> {|KA,KA'|} ⊢ un =<= e.
  Proof.
    split.
    - intro E;etransitivity;[|apply ϵ_inf_e].
      rewrite E;reflexivity.
    - intro E;apply ϵ_spec.
      apply (ax_inf_lang_incl E);reflexivity.
  Qed.

  Lemma ϵ_zero e : ϵ e = e_zero <-> ~ ⟦e⟧ [].
  Proof.
    rewrite <- ϵ_spec;destruct (ϵ_zero_or_un e) as [-> | ->].
    - split;[discriminate|tauto].
    - split;[discriminate|reflexivity].
  Qed.

  Remark ϵ_sub_id e : {|KA,KA'|} ⊢ ϵ e =<= 𝟭.
  Proof. destruct (ϵ_zero_or_un e) as [-> | ->];unfold ax_inf; now auto. Qed.

  Lemma ϵ_add e f :  {|KA,KA'|} ⊢ ϵ (e ∪ f) == ϵ e ∪ ϵ f.
  Proof.
    simpl;destruct (ϵ_zero_or_un e) as [-> | ->];destruct (ϵ_zero_or_un f) as [-> | ->].
    - now auto.
    - transitivity (𝟬∪𝟭);now auto.
    - now auto.
    - now auto.
  Qed.
  
  Lemma ϵ_prod e f :  {|KA,KA'|} ⊢ ϵ (e · f) == ϵ e · ϵ f.
  Proof.
    simpl;destruct (ϵ_zero_or_un e) as [-> | ->];destruct (ϵ_zero_or_un f) as [-> | ->];now auto.
  Qed.

  Global Instance ϵ_proper : Proper (ax_eq KA KA' ==> ax_eq KA KA') ϵ.
  Proof.
    intros e f E;induction E;simpl;auto.
    - eauto.
    - revert IHE1 IHE2.
      destruct (ϵ_zero_or_un e)
        as [-> | ->],
           (ϵ_zero_or_un e')
          as [-> | -> ],
             (ϵ_zero_or_un f)
            as [-> | ->],
               (ϵ_zero_or_un f')
              as [-> | ->];auto.
    - revert IHE1 IHE2.
      destruct (ϵ_zero_or_un e)
        as [-> | ->],
           (ϵ_zero_or_un e')
          as [-> | -> ],
             (ϵ_zero_or_un f)
            as [-> | ->],
               (ϵ_zero_or_un f')
              as [-> | ->];auto.
    - destruct H;simpl;try destruct  (ϵ_zero_or_un e) as [-> | ->];
        try destruct  (ϵ_zero_or_un f) as [-> | ->];
        try destruct  (ϵ_zero_or_un g) as [-> | ->];auto.
    - destruct H;revert IHE;simpl;try destruct  (ϵ_zero_or_un e) as [-> | ->];
        try destruct  (ϵ_zero_or_un f) as [-> | ->];auto.
  Qed.

  Global Instance ϵ_proper_inf : Proper (ax_inf KA KA' ==> ax_inf KA KA') ϵ.
  Proof.
    intros e f E.
    apply ϵ_proper in E as <-.
    unfold ax_inf;simpl.
    destruct (ϵ_zero_or_un e) as [-> | ->]; try destruct (ϵ_zero_or_un f)as [-> | ->];auto.
  Qed.
    
  Lemma ϵ_idem e : ϵ (ϵ e) = ϵ e.
  Proof. destruct (ϵ_zero_or_un e) as [-> | ->];reflexivity. Qed.

  Lemma ϵ_KA e f : {|KA, KA'|}⊢ e == f -> ϵ e = ϵ f.
  Proof.
    intro E;apply soundness in E.
    destruct (ϵ_zero_or_un e) as [E1|E1];rewrite E1.
    - symmetry;apply ϵ_spec,E,ϵ_spec,E1.
    - symmetry;apply ϵ_zero;rewrite <-(E []);apply ϵ_zero,E1.
  Qed.
  
  (** ** Empty language *)
  (** [test0 e] is a boolean, it returns [true] if and only if the language of [e] is empty. *)
  Fixpoint test0 e :=
    match e with
    | e_zero => true
    | e_un | e_star _ | ⟪_⟫ => false
    | e_add e f => test0 e && test0 f
    | e_prod e f => test0 e || test0 f
    end.

  Lemma test0_false e : test0 e = false -> exists u, ⟦e⟧ u.
  Proof.
    induction e;simpl.
    - discriminate.
    - intros _;exists [];reflexivity.
    - rewrite andb_false_iff;intros [h|h].
      + apply IHe1 in h as (u&I);exists u;now left.
      + apply IHe2 in h as (u&I);exists u;now right.
    - rewrite orb_false_iff;intros (h1&h2).
      apply IHe1 in h1 as (u1&I1);apply IHe2 in h2 as (u2&I2).
      exists (u1++u2),u1,u2;tauto.
    - intros _;exists [],0;reflexivity.
    - intros _;exists [x];reflexivity.
  Qed.

  (** [test0 e] is [true] exactly when the equation [e=𝟬] is provable in [KA]. *)
  Lemma test0_spec e : test0 e = true <-> {|KA,KA'|} ⊢ e == e_zero.
  Proof.
    split.
    - induction e;simpl.
      + reflexivity.
      + discriminate.
      + rewrite andb_true_iff;intros (I1&I2);apply IHe1 in I1 as ->;apply IHe2 in I2 as ->.
        auto.
      + rewrite orb_true_iff;intros [I1|I2];[apply IHe1 in I1 as ->|apply IHe2 in I2 as ->];
          auto.
      + discriminate.
      + discriminate.
    - intros h;apply soundness in h.
      apply inf_lang_PartialOrder in h as (h&_).
      case_eq (test0 e);[reflexivity|].
      intro F;exfalso;apply test0_false in F as (u&F).
      apply (h u),F.
  Qed.

  Lemma test0_Σ L :
    test0 (Σ L) = forallb test0 L.
  Proof. induction L;simpl;congruence. Qed.

  
  Lemma test0_KA e f : {|KA, KA'|}⊢ e == f -> test0 e = test0 f.
  Proof.
    intro E;apply eq_true_iff_eq.
    repeat rewrite test0_spec.
    rewrite E;tauto.
  Qed.

  Lemma test0_ϵ e : test0 e = true -> test0 (ϵ e) = true.
  Proof. repeat rewrite test0_spec;intro E;apply ϵ_KA in E as ->;reflexivity. Qed.
      
  (** ** Unit language *)
  (** [test1 e] checks whether [e=𝟭] is provable in [KA]. If the value
  is [false], then [⟦e⟧] is either the empty language or it contains a
  non-empty word [a::u]. *)
  Fixpoint test1 e :=
    match e with
    | e_zero => false
    | e_un => true
    | ⟪_⟫ => false
    | e_star e => test1 e || test0 e
    | e_add e f => (test1 e && test1 f)||(test1 e && test0 f)||(test0 e && test1 f)
    | e_prod e f => test1 e && test1 f
    end.

  Lemma test0_test1_false e : test0 e = false -> test1 e = false -> exists a u, ⟦e⟧ (a::u).
  Proof.
    intros h1 h2;revert h2 h1.
    induction e;simpl;try discriminate;repeat rewrite orb_false_iff||rewrite andb_false_iff;firstorder.
    - apply test0_false in H1 as (v&I).
      exists x,(x0++v),(x::x0),v;tauto.
    - apply test0_false in H0 as ([|a v]&I).
      + exists x,x0,[],(x::x0);tauto.
      + exists a,(v++x::x0),(a::v),(x::x0);tauto.
    - exists x,x0,1,(x::x0),[].
      rewrite app_nil_r;simpl;repeat split;assumption.
    - exists x,[];reflexivity.
  Qed.
          
  
  Lemma test1_spec e : test1 e = true <-> {|KA,KA'|} ⊢ e == e_un.
  Proof.
    split.
    - induction e;simpl.
      + discriminate.
      + reflexivity.
      + repeat rewrite orb_true_iff; repeat rewrite andb_true_iff.
        repeat rewrite test0_spec;intros [[I|I]|I];destruct I as (I1&I2);
          try apply IHe1 in I1 as ->;try apply IHe2 in I2 as -> ;
          try rewrite I1;try rewrite I2;auto.
        transitivity (e_zero ∪ e_un);auto.
      + rewrite andb_true_iff;intros (I1&I2);apply IHe1 in I1 as ->;apply IHe2 in I2 as ->;auto.
      + rewrite orb_true_iff,test0_spec;intros [I|I].
        * apply IHe in I as ->.
          apply ax_inf_PartialOrder;unfold Basics.flip;split.
          -- rewrite <- (ax_eq_ax _ (KA_un_left _));apply star_right_ind.
             apply ax_eq_inf;auto.
          -- apply star_incr.
        * rewrite I;apply ka_zero_star.
      + discriminate.
    - intros h;apply soundness in h.
      case_eq (test1 e);[reflexivity|intro e1].
      case_eq (test0 e);intro e2.
      + apply test0_spec,soundness in e2.
        rewrite e2 in h.
        exfalso;apply (h []);reflexivity.
      + destruct (test0_test1_false e2 e1) as (a&u&I).
        apply h in I;discriminate.
  Qed.

  (** ** Finite sums *)
  Fixpoint join_list {A} f (E : list A) : regexp :=
    match E with
    | [] => 𝟬
    | x::E => (f x) ∪ (join_list f E)
    end.
  
  Notation "Σ_{ X } f" := (join_list f X) (at level 35).

  Lemma join_list_app {A} f (E F : list A) : Σ_{E++F} f ≡0 Σ_{E} f ∪ Σ_{F} f.
  Proof. induction E as [|e E];simpl;[|rewrite IHE];eauto. Qed.

  Lemma join_list_monotone {A} f (E F : list A) : E ⊆ F -> Σ_{E} f ≦0 Σ_{F} f.
  Proof.
    unfold ax_inf;induction E as [|e E];simpl.
    - eauto. 
    - intro L;rewrite <- IHE at 2 by (rewrite <- L;clear;intro;simpl;tauto).
      transitivity (e_add (f e) (e_add (join_list f E) (join_list f F)));[auto|].
      repeat rewrite <- join_list_app.
      assert (Ie : e ∈ (E++F)) by (simpl_In;rewrite <- L;simpl;tauto).
      clear L IHE;induction (E++F).
      + simpl in *;tauto.
      + destruct Ie as [<-|I].
        * simpl;transitivity ((f a∪f a)∪(join_list f l));now auto.
        * simpl;rewrite <- IHl at 2 by assumption.
          transitivity ((f e∪f a)∪(join_list f l));[now auto|].
          transitivity ((f a ∪ f e)∪(join_list f l));now auto.
  Qed.

  Lemma join_list_add {B} (A : list B) f g :
    Σ_{A} (fun x => f x ∪ g x) ≡0 Σ_{A} f ∪ Σ_{A} g.
  Proof.
    induction A;simpl.
    - now auto.
    - rewrite IHA;clear.
      transitivity (f a ∪ (g a ∪ (join_list f A ∪ join_list g A)));[now auto|].
      transitivity (f a ∪ ((g a ∪ join_list f A) ∪ join_list g A));[now auto|].
      transitivity (f a ∪ ((join_list f A ∪ g a) ∪ join_list g A));[now auto|].
      transitivity (f a ∪ (join_list f A ∪ (g a ∪ join_list g A)));[now auto|].
      now auto.
  Qed.

  Lemma join_list_left_distr {B} (A : list B) f e :
    {|KA,KA'|} ⊢ Σ_{A} (fun x => e · f x) == e · Σ_{A} f.
  Proof.
    induction A;simpl.
    - now auto.
    - rewrite IHA;now auto.
  Qed.
  
  Lemma join_list_right_distr {B} (A : list B) f e :
    {|KA,KA'|} ⊢ Σ_{A} (fun x => f x · e) == Σ_{A} f · e.
  Proof.
    induction A;simpl.
    - now auto.
    - rewrite IHA;now auto.
  Qed.
    
  Lemma join_list_equivalent {C} (A B : list C) f g :
    (forall x, x ∈ A -> {|KA,KA'|} ⊢ f x == g x) -> A ≈ B ->
    {|KA,KA'|} ⊢ Σ_{A} f == Σ_{B} g.
  Proof.
    intros hypf hypA.
    transitivity (join_list g A).
    - revert hypf;clear;induction A.
      + reflexivity.
      + intros;simpl;rewrite IHA,hypf.
        * reflexivity.
        * simpl;tauto.
        * intros x Ix;apply hypf;now right.
    - apply KA_ACI0,ax_inf_PartialOrder;split;apply join_list_monotone;rewrite hypA;reflexivity.
  Qed.
  
  Lemma join_list_equivalent_ACI0 {C} (A B : list C) f g :
    (forall x, x ∈ A -> f x ≡0 g x) -> A ≈ B -> Σ_{A} f ≡0 Σ_{B} g .
  Proof.
    intros hypf hypΣ.
    transitivity (join_list g A).
    - revert hypf;clear;induction A.
      + reflexivity.
      + intros;simpl;rewrite IHA,hypf.
        * reflexivity.
        * simpl;tauto.
        * intros x Ix;apply hypf;now right.
    - apply ax_inf_PartialOrder;split;apply join_list_monotone;rewrite hypΣ;reflexivity.
  Qed.
  
  Lemma join_list_zero {B} (A : list B) : Σ_{A} (fun _ => e_zero) ≡0 𝟬.
  Proof. induction A;simpl;[|rewrite IHA];auto. Qed.

  Lemma Σ_app L M : Σ L ∪ Σ M ≡0 Σ (L++M).
  Proof. induction L;simpl;[|rewrite <- IHL];eauto. Qed.
      
  Lemma Σ_incl0 L M : L ⊆ M -> Σ L ≦0 Σ M.
  Proof.
    unfold ax_inf;rewrite Σ_app;revert M;induction L;intros M I.
    - reflexivity.
    - simpl;rewrite IHL by (rewrite <- I;intro;simpl;tauto).
      assert (Ia : a ∈ M) by (apply I;now left).
      clear I L IHL.
      induction M as [|e L].
      + simpl in *;tauto.
      + simpl;destruct Ia as [->|Ia];simpl;
          replace e_add with join in * by reflexivity.
        * transitivity ((a∪a)∪Σ L);auto.
        * transitivity ((a∪e)∪Σ L);[auto|].
          transitivity ((e∪a)∪Σ L);[auto|].
          rewrite <- IHL at 2 by assumption;auto.
  Qed.  
  
  Global Instance Σ_equivalent : Proper (@equivalent _ ==> ax_eq ACI0 Empt) Σ.
  Proof.
    intros l1 l2 E.
    apply incl_PartialOrder in E as (E1&E2);unfold Basics.flip in E2.
    apply Σ_incl0 in E1; apply Σ_incl0 in E2;unfold ax_inf in *.
    rewrite <- E1,<- E2 at 1;auto.
  Qed.
  
  Lemma Σ_map_concat l :
    Σ (map Σ l) ≡0 Σ (concat l).
  Proof.
    induction l;simpl.
    - reflexivity.
    - rewrite  <- Σ_app,IHl;reflexivity.
  Qed.

  Lemma Σ_map_equiv {A} (f g : A -> regexp) (L : list A) :
    (forall e, e ∈ L -> {| KA , KA' |} ⊢  f e == g e) -> {| KA , KA' |} ⊢ Σ (map f L) == Σ (map g L).
  Proof.
    intro hyp.
    induction L as [|e L].
    - reflexivity.
    - simpl;rewrite (hyp e) by (now left).
      apply ax_eq_add;[reflexivity|].
      apply IHL;intros;apply hyp;now right.
  Qed.
    
  Lemma ϵ_Σ_un L : (exists e, e ∈ L /\ ϵ e = un) -> ϵ (Σ L) = un.
  Proof.
    intros (e&Ie&Ee);induction L;simpl;[simpl in Ie;tauto|].
    destruct Ie as [->|Ie].
    - rewrite Ee;simpl;reflexivity.
    - destruct (ϵ_zero_or_un a) as [-> | ->];[reflexivity|].
      rewrite (IHL Ie);reflexivity.
  Qed.

  Lemma ϵ_Σ_zero L : (forall e, e ∈ L -> ϵ e = zero) -> ϵ (Σ L) = zero.
  Proof.
    induction L;simpl;[reflexivity|].
    intros hyp;rewrite (hyp a) by (left;reflexivity).
    rewrite IHL;[reflexivity|].
    intros;apply hyp;now right.
  Qed.
  
  (** ** Finite products *)
  Definition Π : list regexp -> regexp := fold_right prod un.
                                    
  Lemma Π_lang E u :
    ⟦Π E⟧ u <-> exists U, u = fold_right (@app _) [] U
                   /\ ⎢U⎥ = ⎢E⎥
                   /\ forall n, ⟦nth n E un⟧ (nth n U []).
  Proof.
    revert u;induction E;intro u;simpl.
    - split.
      + intros -> ;exists [];split;[reflexivity|split;[reflexivity|]].
        intros [|n];reflexivity.
      + intros ([|]&->&h&h');[reflexivity|discriminate].
    - split.
      + intros (u1&u2&->&I1&I2).
        apply IHE in I2 as (U&E2&len&h).
        exists (u1::U);split;[|split].
        * rewrite E2;reflexivity.
        * simpl;rewrite len;reflexivity.
        * intros [|n];simpl;[assumption|].
          apply h.
      + intros ([|u1 U]&->&len&h);[discriminate|].
        exists u1,(fold_right (@app _) [] U);split;[reflexivity|].
        split;[apply (h 0)|].
        apply IHE;exists U;split;[reflexivity|].
        split;[simpl in *;lia|].
        intros n;apply (h (S n)).
  Qed.

  Lemma fold_star_prodList (e : regexp) l :
   {| KA , KA' |} ⊢  fold_right (fun f1 f2 => e_prod (e_prod e f1) f2) e l == Π (pad e l).
  Proof.
    unfold pad,Π.
    induction l;simpl.
    - eauto.
    - rewrite IHl; clear IHl;simpl.
      replace e_prod with prod by reflexivity.
      auto.
  Qed.

  Remark idem_fold_star (g : regexp) P :
    ⟦fold_right (fun e f => g ⋆ · e · f ) (g ⋆) P⟧ ≃ ⟦g ⋆ · fold_right (fun e f => g ⋆ · e · f ) (g ⋆) P⟧.
  Proof.
    simpl;destruct P;simpl.
    - symmetry;apply (ka_star_dup ⟦g⟧).
    - repeat rewrite (mon_assoc _ _ _).
      rewrite ka_star_dup;reflexivity.
  Qed.

  (** * Derivatives*)
  (** From now on we assume that the alphabet [X] has decidable equality. *)
  Context {decX: decidable_set X }.

  (** This entails quite easily that the syntactic equality of regular
  expressions is decidable. *)
  Global Instance decidable_regexp : decidable_set regexp.
  Proof.
    Fixpoint eq_regexp e1 e2 :=
      match (e1,e2) with
      | (e_zero,e_zero) | (e_un,e_un) => true
      | (⟪x⟫,⟪y⟫) => x =?= y
      | (e_add e1 f1,e_add e2 f2) | (e_prod e1 f1,e_prod e2 f2) =>
                                    eq_regexp e1 e2 && eq_regexp f1 f2
      | (e_star e,e_star f) => eq_regexp e f
      | _  => false
      end.
    apply Build_decidable_set with (eqX:=eq_regexp).
    intros e f;apply iff_reflect;revert f;induction e;intros [| |f1 f2|f1 f2|f|y];simpl;
      try (split;discriminate||reflexivity).
    - rewrite andb_true_iff;rewrite <- IHe1,<-IHe2.
      split;[intro h;inversion h;split|intros (->&->)];reflexivity.
    - rewrite andb_true_iff;rewrite <- IHe1,<-IHe2.
      split;[intro h;inversion h;split|intros (->&->)];reflexivity.
    - rewrite <- IHe;split;[intro h;inversion h|intros ->];reflexivity.
    - unfold_eqX;[tauto|split;[intro h;inversion h;tauto|discriminate]].
  Qed.

  (** [δ x e] is the Brzozowski derivative of [e] at [x]. *)
  Fixpoint δ (x:X) (e : regexp) :=
    match e with
    | e_un | e_zero => e_zero
    | ⟪y⟫ => if x =?= y
            then e_un
            else e_zero
    | e_prod e f =>
      if ϵ e =?= 𝟭
      then δ x e · f ∪ δ x f
      else δ x e · f
    | e_add e f => δ x e ∪ δ x f
    | e_star e => δ x e · e⋆
    end.

  
  Proposition fundamental_theorem e A :
    Var e ⊆ A -> {|KA,KA'|} ⊢ e == ϵ e ∪ Σ_{A} (fun x => ⟪x⟫ · δ x e).
  Proof.
    intro V;induction e.
    - simpl;clear.
      transitivity (𝟬 ∪ 𝟬);[now auto|].
      apply ax_eq_add;[reflexivity|].
      rewrite join_list_right_distr;auto.
    - simpl;clear.
      rewrite join_list_right_distr;auto.
      transitivity (𝟬 ∪ 𝟭);[now auto|].
      transitivity (𝟭 ∪ 𝟬);now auto.
    - replace (e_add e1 e2) with (e1 ∪ e2) by reflexivity.
      simpl in V;apply incl_app_split in V.
      rewrite ϵ_add.
      rewrite IHe1,IHe2 at 1 by tauto;clear.
      transitivity ((ϵ e1 ∪ ϵ e2) ∪ join_list (fun x : X => ⟪ x ⟫ · δ x e1 ∪ ⟪ x ⟫ · δ x e2) A).
      + rewrite (KA_ACI0 (join_list_add _ _ _)).
        apply refactor.
      + apply ax_eq_add;[reflexivity|].
        apply join_list_equivalent.
        * intros x _;simpl;auto.
        * reflexivity.
    - rewrite ϵ_prod;simpl;replace e_prod with prod by reflexivity.
      simpl in V;apply incl_app_split in V.
      destruct V as (E1&E2);apply IHe1 in E1;apply IHe2 in E2;clear IHe1 IHe2.
      remember (join_list (fun x : X => ⟪ x ⟫ · δ x e1) A) as f1.
      remember (join_list (fun x : X => ⟪ x ⟫ · δ x e2) A) as f2.
      revert E1;destruct (ϵ_zero_or_un e1) as [-> | ->];intros;simpl_eqX.
      + transitivity ((𝟭 · ϵ e2) ∪ join_list (fun x : X => ((⟪ x ⟫ · δ x e1) · e2)
                                                             ∪ (⟪ x ⟫ · δ x e2)) A);
          [|apply ax_eq_add;[reflexivity|];apply join_list_equivalent;
            [intros x _;transitivity ((⟪ x ⟫ · (δ x e1 · e2)) ∪ (⟪ x ⟫ · δ x e2));auto|reflexivity]].
        rewrite (KA_ACI0 (join_list_add _ _ _)).
        rewrite join_list_right_distr.
        rewrite <- Heqf1,<-Heqf2.
        transitivity (ϵ e2 ∪ (f2 ∪ f1 · e2));[|auto].
        transitivity ((ϵ e2 ∪ f2) ∪ f1 · e2);[|auto].
        rewrite <- E2.
        transitivity ((𝟭 · e2) ∪ f1 · e2);[|auto].
        rewrite E1;auto.
      + transitivity ((𝟬 · ϵ e2) ∪ join_list (fun x : X => (⟪ x ⟫ · δ x e1) · e2) A);
          [|apply ax_eq_add;[reflexivity|];apply join_list_equivalent;
            [intros x _;transitivity (⟪ x ⟫ · (δ x e1 · e2));auto|reflexivity]].
        rewrite join_list_right_distr.
        rewrite <-Heqf1.
        rewrite E1.
        transitivity (𝟬 · e2 ∪ f1 · e2);[auto|].
        transitivity (𝟬 ∪ f1 · e2);auto.
    - apply ax_inf_PartialOrder;
        cut ( {|KA, KA'|}⊢ join_list (fun x : X => ⟪ x ⟫ · δ x (e ⋆)) A
              ==join_list (fun x : X => (⟪ x ⟫ · δ x e) · e ⋆) A);
        [intro E;unfold Basics.flip;split;rewrite E;clear E|].
      + replace e_star with star by reflexivity.
        replace (ϵ (e⋆)) with 𝟭 by reflexivity.
        apply IHe in V;clear IHe.
        cut ({|KA, KA'|}⊢ e⋆ =<= ( 𝟭 ∪ join_list (fun x => (⟪ x ⟫ · δ x e) · e ⋆) A) ·e ⋆).
        * intros ->; apply star_right_ind.
          rewrite join_list_right_distr.
          transitivity  (𝟭·e ∪ (join_list (fun x : X => ⟪ x ⟫ · δ x e) A · e ⋆)· e);
            [apply ax_eq_inf;now auto|].
          apply inf_join_inf.
          -- transitivity e;[apply ax_eq_inf;now auto|].
             rewrite V at 1.
             apply proper_join_inf.
             ++ apply ϵ_sub_id.
             ++ rewrite <- one_inf_star,right_unit;reflexivity.
          -- etransitivity;[|apply inf_cup_right].
             rewrite <- (mon_assoc _ _ _).
             apply proper_prod_inf;[reflexivity|].
             rewrite (star_incr e) at 2;rewrite ka_star_dup;reflexivity.
        * transitivity (𝟭·e⋆);[apply ax_eq_inf;now auto|].
          apply prod_ax_inf;[|reflexivity].
          apply inf_cup_left.
      + etransitivity;[|apply ax_eq_inf;symmetry;apply ka_star_unfold_eq].
        apply proper_join_inf;[reflexivity|].
        rewrite join_list_right_distr.
        apply proper_prod_inf;[|reflexivity].
        rewrite (IHe V).
        apply inf_cup_right.
      + apply join_list_equivalent;[|reflexivity].
        now intros x _;simpl;repeat rewrite prod'_prod;auto.
    - assert (E: A ≈ x :: (rm x A)).
      + intro z;simpl_In.
        rewrite rm_In.
        destruct_eqX x z.
        * split;[tauto|].
          intros _;apply V;now left.
        * tauto.
      + transitivity (ϵ ⟪ x ⟫ ∪ join_list (fun x0 : X => ⟪ x0 ⟫ · δ x0 ⟪ x ⟫) (x::A∖x)).
        * transitivity (𝟬∪⟪x⟫);[now auto|].
          transitivity (⟪x⟫∪𝟬);[now auto|].
          transitivity (𝟬∪(⟪x⟫∪𝟬));[now auto|].
          simpl;apply ax_eq_add;[reflexivity|].
          repeat rewrite prod'_prod||rewrite join'_join; apply ax_eq_add;[simpl;simpl_beq;now auto|].
          rewrite <- (KA_ACI0 (join_list_zero (A ∖ x))) at 1;apply join_list_equivalent;[|reflexivity].
          intros y I.
          apply rm_In in I as (I&N).
          simpl_beq;auto.
        * apply join_ax_eq;[reflexivity|].
          apply join_list_equivalent;[|symmetry;apply E].
          intros;reflexivity.
  Qed.

  Lemma δ_lang e a w : ⟦e⟧ (a::w) <-> ⟦δ a e⟧ w.
  Proof.
    revert a w;induction e as [| |e IHe f IHf |e IHe f IHf |e|x];intros y w;simpl.
    - tauto.
    - split;[discriminate|intro F;exfalso;apply F].
    - unfold join,joinLang;rewrite IHe,IHf;tauto.
    - split.
      + intros (u&v&E&Iu&Iv).
        destruct u as [|? u].
        * simpl in E;subst.
          apply ϵ_spec in Iu as ->;simpl_beq.
          right;apply IHf,Iv.
        * apply IHe in Iu;inversion E;subst;clear E.
          unfold_eqX;[left|];exists u,v;tauto.
      + unfold_eqX;[intros [(u&v&->&Iu&Iv)|Iw]|intros (u&v&->&Iu&Iv)];
          apply IHe in Iu || apply IHf in Iw.
        * exists (y::u),v;tauto.
        * exists [],(y::w);rewrite <- ϵ_spec;tauto.
        * exists (y::u),v;tauto.
    - unfold join,joinLang,prod,prodLang;setoid_rewrite <- IHe;clear IHe;split.
      + intros (n&In).
        revert y w In;induction n;intros.
        * simpl in In;discriminate.
        * destruct In as ([|x u]&v&E&Iu&Iv).
          -- simpl in E;subst;apply IHn,Iv.
          -- clear IHn;inversion E;subst;clear E.
             exists u,v;repeat split;[|exists n];assumption.
      + intros (u&v&->&Iu&n&Iv).
        exists (S n),(y::u),v;tauto.
    - unfold_eqX;simpl;split.
      + destruct w;[reflexivity|discriminate].
      + intros ->;reflexivity.
      + intro E;apply N;inversion E;reflexivity.
      + intro F;exfalso;apply F.
  Qed.

  Lemma δ_inf_e a e : {| KA , KA' |} ⊢ ⟪a⟫ · (δ a e) =<= e.
  Proof.
    assert (E: Var e ⊆ a::Var e) by (intro;simpl;tauto).
    apply fundamental_theorem in E.
    etransitivity;[|apply ax_eq_inf;symmetry;apply E].
    etransitivity;[|apply inf_cup_right].
    apply inf_cup_left.
  Qed.

  Lemma δ_Σ l L : δ l (Σ L) = Σ (map (δ l) L).
  Proof.
    induction L;[reflexivity|].
    simpl;rewrite IHL;reflexivity.
  Qed.
  
  Lemma δ_proper_KA l :
    Proper ((ax_eq KA KA') ==> (ax_eq KA KA')) (δ l).
  Proof.
    intros e1 e2 E;induction E.
    - reflexivity.
    - symmetry;assumption.
    - etransitivity;eassumption.
    - simpl;unfold_eqX.
      + rewrite IHE1,IHE2,E2;reflexivity.
      + exfalso.
        apply soundness in E1;apply ϵ_spec,E1,ϵ_spec in E.
        apply N,E.
      + exfalso.
        apply soundness in E1;apply ϵ_spec,E1,ϵ_spec in E.
        apply N,E.
      + rewrite IHE1,E2;reflexivity.
    - simpl;rewrite IHE1,IHE2;reflexivity.
    - simpl;rewrite IHE,E;reflexivity.
    - destruct H;simpl.
      + unfold_eqX;simpl.
        * rewrite (ax_eq_ax _ (KA_right_distr _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_add_assoc _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          reflexivity.
        * exfalso;revert E0 N;simpl.
          destruct (ϵ_zero_or_un f) as [-> | ->];[tauto|discriminate].
        * rewrite (ax_eq_ax _ (KA_right_distr _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_add_assoc _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          reflexivity.
        * exfalso;revert E N;simpl.
          destruct (ϵ_zero_or_un e) as [-> | ->];[tauto|discriminate].
        * repeat rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _));reflexivity.
      + apply ax_eq_ax;auto.
      + apply ax_eq_ax;auto.
      + unfold_eqX;repeat rewrite (ax_eq_ax _ (KA_right_distr _ _ _))
                   || rewrite (ax_eq_ax _ (KA_left_distr _ _ _))
                   || rewrite (ax_eq_ax _ (KA_add_assoc _ _ _))
                   || rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _)).
        * apply ax_eq_add;[|reflexivity].
          rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)), <- (ax_eq_ax _ (KA_add_assoc _ _ _)).
          apply ax_eq_add;[reflexivity|].
          apply ax_eq_ax;auto.
        * reflexivity.
      + destruct (ϵ_zero_or_un e) as [-> | ->];destruct (ϵ_zero_or_un f) as [-> | ->];simpl_eqX;
          repeat rewrite (ax_eq_ax _ (KA_right_distr _ _ _))
          || rewrite (ax_eq_ax _ (KA_left_distr _ _ _))
          || rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _));
          (apply ax_eq_add;[reflexivity|]);[|now auto |now auto|now auto].
        transitivity (δ l f · g ∪ (δ l g∪δ l g));[now auto|].
        transitivity ((δ l f · g ∪ δ l g)∪δ l g);[now auto|].
        transitivity ((δ l g ∪ δ l f · g)∪δ l g);[now auto|].
        auto.
      + apply ax_eq_ax,KA_zero.
      + simpl_eqX.
        transitivity ((𝟬·e)∪δ l e);[reflexivity|].
        transitivity (𝟬∪δ l e);[now auto|].
        apply ax_eq_ax;auto.
      + unfold_eqX.
        * replace e_zero with zero by reflexivity.
          transitivity (δ l e ∪ zero);[now auto|].
          transitivity (zero ∪ δ l e);now auto.
        * auto.
      + simpl_eqX.
        replace e_zero with zero by reflexivity.
        auto.
      + unfold_eqX.
        * transitivity (δ l e · zero ∪ zero);[now auto|].
          transitivity zero;[|now auto].
          transitivity (zero ∪ zero);auto.
        * transitivity zero;now auto.
      + auto.
      + replace e_zero with zero by reflexivity.
        rewrite (ax_eq_ax _ (KA_zero _)).
        unfold_eqX;[|now auto].
        transitivity (δ l e · e⋆ ∪ δ l e · e⋆);now auto.   
    - destruct H;simpl in *;revert IHE;simpl_eqX;unfold_eqX;intros IHE.
      + rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)) in IHE.
        rewrite (ax_eq_ax _ (KA_idem _)) in IHE.
        cut ({|KA, KA'|}⊢e⋆·f =<= f).
        * intro L.
          rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)).
          rewrite (ax_eq_ax _ (KA_idem _)).
          cut ({|KA, KA'|}⊢(δ l e · e ⋆) · f =<= δ l f);[intro H;apply H|].
          rewrite <- (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          rewrite L.
          apply IHE.
        * eapply ax_eq_ax';[|apply E].
          auto.
      + cut ({|KA, KA'|}⊢e⋆·f =<= f).
        * intro L.
          rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)).
          rewrite (ax_eq_ax _ (KA_idem _)).
          cut ({|KA, KA'|}⊢(δ l e · e ⋆) · f =<= δ l f);[intro H;apply H|].
          rewrite <- (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          rewrite L.
          apply IHE.
        * eapply ax_eq_ax';[|apply E].
          auto.
      + cut ({|KA, KA'|}⊢δ l e · f ⋆ ∪ δ l f · f ⋆ =<= δ l e);[intro H;apply H|].
        transitivity (δ l e · f ⋆ ∪ δ l e · f ⋆).
        * apply proper_join_inf;[reflexivity|].
           apply proper_prod_inf;[|reflexivity].
           etransitivity;[|apply IHE].
           apply inf_cup_right.
        * rewrite (ax_eq_ax _ (KA_idem _)).
           eapply ax_eq_ax';[apply KA_star_right_ind|].
           cut ({|KA, KA'|}⊢δ l e · f =<= δ l e);[intro H;apply H|].
           transitivity (δ l e · f ∪ δ l f);[apply inf_cup_left|apply IHE].
      + cut ({|KA, KA'|}⊢δ l e · f ⋆ =<= δ l e);[intro H;apply H|].
        eapply ax_eq_ax';[apply KA_star_right_ind|].
        cut ({|KA, KA'|}⊢δ l e · f =<= δ l e);[intro H;apply H|apply IHE].
  Qed.

  Lemma δ_proper_KA_inf l :
    Proper ((ax_inf KA KA') ==> (ax_inf KA KA')) (δ l).
  Proof.
    intros e1 e2 E.
    apply δ_proper_KA with (l:=l) in E.
    simpl in E;apply E.
  Qed.

  Lemma test0_δ x e : test0 e = true -> test0 (δ x e) = true.
  Proof.
    induction e;simpl;try reflexivity||discriminate.
    - rewrite andb_true_iff;intros (T1&T2);rewrite IHe1,IHe2;tauto.
    - destruct (ϵ_zero_or_un e1) as [E|E];rewrite orb_true_iff;intros [T|T].
      + apply test0_ϵ in T;rewrite E in T;discriminate.
      + rewrite E;simpl_eqX;simpl.
        rewrite IHe2,T,orb_true_r;tauto.
      + rewrite E;simpl_eqX;simpl.
        rewrite IHe1;tauto.
      + rewrite E;simpl_eqX;simpl.
        rewrite T,orb_true_r;tauto.
  Qed.

  Remark δ_prod l e f : {|KA, KA'|}⊢ δ l (e·f) == δ l e ·f ∪ ϵ e·δ l f.
  Proof.
    simpl;destruct (ϵ_zero_or_un e) as [-> | ->];simpl_eqX.
    - replace e_un with un by reflexivity.
      etransitivity;[|apply proper_join;[reflexivity|symmetry;apply left_unit]].
      reflexivity.
    - replace e_zero with zero by reflexivity.
      etransitivity;[|apply proper_join;[reflexivity|symmetry;apply left_absorbing]].
      etransitivity;[|symmetry;apply right_unit].
      reflexivity.
  Qed.

  (** [δ] may be extended to words in the obvious way. *)
  Fixpoint δ_words w e :=
    match w with
    | [] => e
    | a::w => δ_words w (δ a e)
    end.

  Notation " δ⋆ " := δ_words.

  Lemma δ_words_zero w : δ⋆ w e_zero = e_zero.
  Proof.
    induction w;simpl.
    - reflexivity.
    - rewrite IHw ;reflexivity.
  Qed.

  Lemma δ_words_add e f w : δ⋆ w (e ∪ f) = (δ⋆ w e) ∪ (δ⋆ w f).
  Proof.
    revert e f;induction w as [|a w];intros e f;simpl;[reflexivity|].
    rewrite <- IHw;f_equal;clear;destruct e,f;unfold join';simpl;try reflexivity.
  Qed.

  Lemma δ_words_lang e : ⟦ e ⟧ ≃ (fun w => ϵ (δ⋆ w e) = 𝟭).
  Proof.
    intro w;revert e;induction w;intro e;simpl.
    - symmetry;apply ϵ_spec.
    - rewrite δ_lang,IHw;reflexivity.
  Qed.

  Lemma δ_words_last e u a : δ⋆ (u++[a]) e = δ a (δ⋆ u e).
  Proof.
    revert e;induction u;intro e;simpl;[reflexivity|apply IHu].
  Qed.

  (** * Prefixes of a regular language *)
  Fixpoint prefixes e :=
    match e with
    | e_zero => []
    | e_un => [𝟭]
    | ⟪x⟫ => [𝟭;⟪x⟫]
    | e_add e f => prefixes e ++ prefixes f
    | e_prod e f => if test0 e || test0 f
                   then []
                   else prefixes e ++ map (prod e) (prefixes f)
    | e_star e =>  if test0 e
                  then [𝟭]
                  else map (prod (e⋆)) (prefixes e)
    end.

  Lemma prefixes_spec e : forall u, ⟦Σ (prefixes e)⟧ u <-> exists v, ⟦e⟧ (u++v).
  Proof.
    induction e;intro u;simpl.
    - split;[intros I|intros (v&I)];exfalso;apply I.
    - split.
      + intros [->|I];[|exfalso;apply I].
        exists [];reflexivity.
      + intros (v&I);apply app_eq_nil in I as (->&->).
        left;reflexivity.
    - rewrite <- (soundness (KA_ACI0 (Σ_app (prefixes e1) (prefixes e2))) u);simpl.
      Transparent joinLang.
      unfold join at 1,joinLang;simpl.
      rewrite IHe1,IHe2;clear IHe1 IHe2.
      firstorder.
      Opaque joinLang.
    - case_eq (test0 e1 || test0 e2).
      + intro h;simpl.
        split;[intro I;exfalso;apply I|].
        intros (v&w1&w2&_&I1&I2).
        apply orb_true_iff in h as [h|h];apply test0_spec,soundness in h.
        * apply h in I1;apply I1.
        * apply h in I2;apply I2.
      + intros F.
        rewrite <- (soundness (KA_ACI0 (Σ_app (prefixes e1) _)) u);simpl.
        Transparent joinLang.
        unfold join at 1,joinLang;simpl.
        rewrite <- (soundness (Σ_distr_l _ _) u);simpl.
        rewrite IHe1;clear IHe1.
        split.
        * intros [(v&Iv)|(u1&u2&->&I1&I2)].
          -- apply orb_false_iff in F as (_&F);apply test0_false in F as (w&Iw).
             exists (v++w),(u++v),w;rewrite app_ass;tauto.
          -- apply IHe2 in I2 as (v&I2);exists v,u1,(u2++v);rewrite app_ass;tauto.
        * intros (v&w1&w2&E&I1&I2).
          levi E;subst;clear E.
          -- left;exists [];rewrite app_nil_r;tauto.
          -- right;exists w1,(a::w);split;[reflexivity|];split;[assumption|].
             apply IHe2;exists v;apply I2.
          -- left;exists (a::w);apply I1.
             Opaque joinLang.
    - case_eq (test0 e).
      + intro h;simpl.
        apply test0_spec,soundness in h.
        split;[intros [->|I];[exists[],0;reflexivity|exfalso;apply I]|].
        intros (v&[|n]&I);[apply app_eq_nil in I as (->&_);left;reflexivity|].
        destruct I as (u1&_&_&I&_).
        exfalso;apply h in I;apply I.
      + intros F.
        rewrite <- (soundness (Σ_distr_l _ _) u);simpl;split.
        * intros (u1&u2&->&(n&In)&I).
          apply IHe in I as (v&I).
          exists v,(S n);apply iter_lang_last.
          rewrite app_ass;exists u1,(u2++v);tauto.
        * intros (v&n&I);revert v I;induction n;intros v I.
          -- apply app_eq_nil in I as (->&_).
             exists [],[];split;[reflexivity|].
             split;[exists 0;reflexivity|].
             apply IHe;apply test0_false in F as (w&Iw);exists w;apply Iw.
          -- apply iter_lang_last in I as (u1&u2&E&I1&I2).
             levi E;subst;clear E.
             ++ exists u1,[];rewrite app_nil_r.
                split;[reflexivity|];split;[exists n;apply I1|].
                apply IHe;exists u2;apply I2.
             ++ exists u1,(a::w);split;[reflexivity|].
                split;[exists n;apply I1|].
                apply IHe;exists v;apply I2.
             ++ apply (IHn (a::w)),I1.
    - split.
      + intros [->|[->|F]].
        * exists [x];reflexivity.
        * exists [];reflexivity.
        * exfalso;apply F.
      + intros (v&E);destruct u as [|y[|z u]];simpl in *;inversion E;subst.
        * left;reflexivity.
        * right;left;reflexivity.
  Qed.

  Lemma test0_prefixes e : test0 e = true -> prefixes e = [].
  Proof.
    induction e;simpl;firstorder (try discriminate).
    - apply andb_true_iff in H as (h1&h2).
      rewrite IHe1,IHe2 by assumption.
      reflexivity.
    - rewrite H;reflexivity.
  Qed.

End regexp.

Notation "Σ_{ X } f" := (join_list f X) (at level 35).
Notation " ⟪ l ⟫" := (atomic l).

Notation " ⟦ e ⟧ " := (reg_lang e).

Notation " {| Ax , Ax' |} ⊢ e == f " := (ax_eq Ax Ax' e f) (at level 80).

Notation " {| Ax , Ax' |} ⊢ e =<= f " := (ax_inf Ax Ax' e f) (at level 80).
Hint Constructors ax_eq.
Hint Constructors KA.
Hint Constructors KA'.
Notation " e =KA f " := (ax_eq KA KA' e f) (at level 80).
Notation " e <=KA f " := (ax_inf KA KA' e f) (at level 80).
Notation " δ⋆ " := δ_words.

Section Antimirov.
  Context {X : Set}{decX: decidable_set X }.

  (** * Antimirov derivatives *)
  
  Fixpoint δA a e :=
    match e with
    | e_zero | e_un => []
    | ⟪ b ⟫ => if a =?= b then [e_un] else []
    | e_add e f => δA a e ++ δA a f
    | e_prod e f =>
      map (fun g => g · f) (δA a e)++(if ϵ e =?= e_un then (δA a f) else [])
    | e_star e => map (fun g => g · e⋆) (δA a e)
    end.

  Fixpoint stateSpace (e:@regexp X) :=
    e::match e with
       | e_zero => []
       | e_un => []
       | ⟪ x ⟫ => [e_un]
       | e_add e f => (stateSpace e) ++ (stateSpace f)
       | e_prod e f => map (fun g => g · f) (stateSpace e)++(if negb (test0 e) then stateSpace f else [])
       | e_star e => map (fun g => g · e⋆) (stateSpace e)
       end.

  Lemma stateSpace_refl e : e ∈ stateSpace e.
  Proof. destruct e;now left. Qed.

  Lemma test0_stateSpace e f :
    test0 f = true -> e ∈ stateSpace f -> test0 e = true.
  Proof.
    revert e;induction f;intro e;simpl;simpl_In;
      repeat rewrite andb_true_iff||rewrite orb_true_iff.
    - intros _ [<-|F];[reflexivity|tauto].
    - discriminate.
    - intros (IH1&IH2) [<-|[I|I]].
      + simpl;rewrite IH1,IH2;reflexivity.
      + apply IHf1;assumption.
      + apply IHf2;assumption.
    - intros [T|T] [<-|[I|I]];simpl.
      + rewrite T;reflexivity.
      + apply in_map_iff in I as (g&<-&Ig);simpl.
        rewrite (IHf1 _ T Ig);reflexivity.
      + rewrite T in I;simpl in I;tauto.
      + rewrite T,orb_true_r;reflexivity.
      + apply in_map_iff in I as (g&<-&Ig);simpl.
        rewrite T,orb_true_r;reflexivity.
      + destruct (test0 f1);simpl in I;[tauto|].
        apply (IHf2 _ T I).
    - discriminate.
    - discriminate.
  Qed.

  Lemma stateSpace_trans e f :
    f ∈ stateSpace e -> stateSpace f ⊆ stateSpace e.
  Proof.
    revert f;induction e;simpl;intros f;try tauto.
    - intros [<-|F];[reflexivity|tauto].
    - intros [<-|F];[reflexivity|tauto].
    - simpl_In;intros [<-|[If|If]];[reflexivity|apply IHe1 in If as ->|apply IHe2 in If as ->];
        apply incl_tl.
      + apply incl_appl;reflexivity.
      + apply incl_appr;reflexivity.
    - intros [<-|I];[reflexivity|revert I].
      simpl_In;repeat rewrite in_map_iff.
      intros [(f'&<-&I)|I].
      + apply IHe1 in I.
        intros g;simpl;simpl_In;repeat rewrite in_map_iff.
        intros [<-|[(g'&<-&Ig)|Ig]].
        * right;left;exists f';split.
          -- reflexivity.
          -- apply I,stateSpace_refl.
        * right;left;exists g';split.
          -- reflexivity.
          -- apply I,Ig.
        * revert Ig;case_eq (test0 f');simpl;[tauto|].
          case_eq (test0 e1);simpl;[|tauto].
          intros T1 T2;exfalso.
          cut (test0 f' = true);[intros E;rewrite E in T2;discriminate|].
          apply (test0_stateSpace T1).
          apply I,stateSpace_refl.
      + revert I; case_eq (test0 e1);simpl;[tauto|].
        intros _ I; apply IHe2 in I as ->;intro;simpl_In;tauto.
    - intros [<-|I];[reflexivity|revert I].
      rewrite in_map_iff;intros (f'&<-&I).
      apply IHe in I;intro g;simpl.
      simpl_In;repeat rewrite in_map_iff.
      intros [<-|[(g'&<-&Ig')|Ig]].
      + right;exists f';split;[reflexivity|].
        apply I,stateSpace_refl.
      + right;exists g';split;[reflexivity|].
        apply I,Ig'.
      + revert Ig.
        destruct (test0 f');simpl;[tauto|].
        rewrite in_map_iff;intros [<-|(g'&<-&Ig')].
        * left;reflexivity.
        * right;exists g';split;[reflexivity|].
          apply Ig'.
    - intros [<-|[<-|F]];[reflexivity| |tauto].
      intros ? [<-|F];[|simpl in F;tauto].
      now right;left.
  Qed.


  Lemma δA_stateSpace e a : δA a e ⊆ stateSpace e.
  Proof.
    induction e;simpl;apply incl_tl;try reflexivity.
    - rewrite IHe1,IHe2;apply reflexivity.
    - case_eq (test0 e1);intro T;simpl.
      + rewrite app_nil_r.
        unfold_eqX.
        * exfalso.
          apply ϵ_spec in E.
          apply test0_spec,soundness in T.
          apply T in E;apply E.
        * rewrite app_nil_r.
          rewrite <- IHe1;reflexivity.
      + rewrite <- IHe1,<-IHe2.
        apply incl_app_Proper;[reflexivity|].
        destruct (ϵ e1 =?= e_un);[reflexivity|apply incl_nil].
    - rewrite IHe;reflexivity.
    - destruct_eqX a x;[reflexivity|apply incl_nil].
  Qed.
  
  Lemma Antimirov_lang e a w : ⟦e⟧ (a::w) <-> exists f, f ∈ δA a e /\ ⟦f⟧ w.
  Proof.
    revert w;induction e;intro w;simpl;split.
    - intro F;exfalso;apply F.
    - firstorder.
    - intro F;discriminate.
    - firstorder.
    - intros [I|I].
      + apply IHe1 in I as (f&If);exists f;simpl_In;tauto.
      + apply IHe2 in I as (f&If);exists f;simpl_In;tauto.
    - intros (f&If&Iw);simpl_In in If;destruct If as [If|If].
      + left;apply IHe1;exists f;tauto.
      + right;apply IHe2;exists f;tauto.
    - intros ([|b u]&v&E&I1&I2).
      + apply ϵ_spec in I1 as ->;simpl_beq.
        simpl in E;subst.
        apply IHe2 in I2 as (f&If&Iw).
        exists f;simpl_In;tauto.
      + simpl in E;inversion E;subst;clear E.
        apply IHe1 in I1 as (f&If&Iw).
        exists (f·e2);split.
        * simpl_In;left;apply in_map_iff;exists f;tauto.
        * exists u,v;tauto.
    - intros (f&If&Iw);simpl_In in If;destruct If as [If|If].
      + apply in_map_iff in If as (f'&<-&If).
        destruct Iw as (u1&u2&->&I1&I2).
        exists (a::u1),u2;repeat split.
        * apply IHe1;exists f';tauto.
        * assumption.
      + destruct_eqX (ϵ e1) (@e_un X);[|exfalso;apply If].
        exists [],(a::w);repeat split.
        * apply ϵ_spec,E.
        * apply IHe2;exists f;tauto.
    - intros (n&In);revert In;induction n.
      + discriminate.
      + intros (u&v&E&I1&I2).
        destruct u as [|b u].
        * simpl in E;subst;apply IHn,I2.
        * simpl in E;inversion E;subst;clear IHn E.
          apply IHe in I1 as (f&If&Iu).
          exists (f·e⋆);split.
          -- apply in_map_iff;exists f;tauto.
          -- exists u,v;repeat split.
             ++ assumption.
             ++ exists n;tauto.
    - intros (f&If&Iw).
      apply in_map_iff in If as (f'&<-&If').
      destruct Iw as (u&v&->&I1&n&I2).
      exists (S n),(a::u),v;repeat split.
      + apply IHe;exists f';tauto.
      + assumption.
    - intros E;inversion E;subst.
      simpl_beq;exists e_un;split.
      + now left.
      + reflexivity.
    - destruct_eqX a x;subst;intros (f&If&Iw).
      + destruct If as [<-|F];[|exfalso;apply F].
        rewrite Iw;reflexivity.
      + exfalso;apply If.
  Qed.

  Remark In_δA_stateSpace_incl : (forall e f a, f ∈ δA a e -> stateSpace f ⊆ stateSpace e).
  Proof.
    intros;apply stateSpace_trans.
    apply δA_stateSpace in H;assumption.
  Qed.

 Lemma test0_δA e x : test0 e = true -> forall f, f ∈ δA x e -> test0 f = true.
  Proof.
    induction e;simpl;try tauto||discriminate.
    - rewrite andb_true_iff;intros (h1&h2) f;simpl_In;intros [I|I];
        [apply IHe1,I|apply IHe2,I];assumption.
    - rewrite orb_true_iff;intros [h|h] f;simpl_In;
        (intros [I|I];[apply in_map_iff in I as (g&<-&Ig)|revert I;unfold_eqX;simpl;[|tauto]]).
      + simpl;apply orb_true_iff;left;apply IHe1;assumption.
      + exfalso.
        apply test0_spec,soundness in h;simpl in h.
        exfalso;cut (𝟬 (@nil X));[tauto|].
        apply h,ϵ_spec,E.
      + simpl;apply orb_true_iff;right;assumption.
      + apply IHe2,h.
  Qed.

  Lemma stateSpace_Var e f : e ∈ stateSpace f -> Var e ⊆ Var f.
  Proof.
    revert e;induction f;intros e;simpl.
    - intros [<-|F];[reflexivity|tauto].
    - intros [<-|F];[reflexivity|tauto].
    - simpl_In;intros [<-|[I|I]];
        [simpl;reflexivity
        |rewrite IHf1 by assumption;intro;simpl_In;tauto
        |rewrite IHf2 by assumption;intro;simpl_In;tauto].
    - simpl_In;intros [<-|[I|I]];
        [simpl;reflexivity
        |
        |destruct (test0 f1);simpl in I;[tauto|];rewrite IHf2 by assumption;intro;simpl_In;tauto].
      apply in_map_iff in I as (g&<-&Ig);simpl.
      rewrite IHf1 by assumption;reflexivity.
    - simpl_In;intros [<-|I];
        [simpl;reflexivity|].
      apply in_map_iff in I as (g&<-&Ig);simpl.
      rewrite IHf by assumption;intro;simpl_In;tauto.
    - intros [<-|[<-|F]];[reflexivity|apply incl_nil|tauto].
  Qed.
End Antimirov.
(* begin hide *)
Section simulation_expr.
  Context {X : Set}{dec_X : decidable_set X}.
  Notation E := (@regexp X).

  CoInductive similar (e f : E) : Prop :=
  | simulation_step : ϵ e <=KA ϵ f -> (forall a, similar (δ a e) (δ a f)) -> similar e f.

  Lemma simulation_language (e f : E) :
    ⟦e⟧ ≲ ⟦f⟧ <-> similar e f.
  Proof.
    split.
    - revert e f;cofix hE.
      intros e f hL;apply simulation_step.
      + destruct (ϵ_zero_or_un e) as [e1|e0].
        * rewrite e1.
          apply ϵ_spec,hL,ϵ_spec in e1 as ->;reflexivity.
        * rewrite e0;unfold ax_inf;eauto.
      + intros a;apply hE.
        intros u;repeat rewrite <- δ_lang;apply hL.
    - intros hE u;revert e f hE.
      induction u;intros e f hE;inversion hE as [h1 hS]. 
      + rewrite (ϵ_inf_e f) in h1.
        apply ax_inf_lang_incl in h1.
        intros e1;apply ϵ_spec in e1.
        apply h1;rewrite e1;reflexivity.
      + repeat rewrite δ_lang.
        apply IHu,hS.
  Qed.

  Lemma similar_join e f g : similar (e ∪ f) g -> similar e g /\ similar f g.
  Proof.
    repeat rewrite <-simulation_language.
    intros L;split;rewrite <- L;simpl;[apply inf_cup_left|apply inf_cup_right].
  Qed.
     
End simulation_expr.
(* end hide *)