(** * RIS.regexp : regular expressions and the free Kleene algebra. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Require Import tools algebra language.
Require Import Bool.
Section regexp.
  Context {X : Set}.
  (** * Definitions *)
  (** Regular expressions are terms generated by the following syntax. *)
  Inductive regexp : Set :=
  | e_zero : regexp
  | e_un : regexp
  | e_add : regexp -> regexp -> regexp
  | e_prod : regexp -> regexp -> regexp
  | e_star : regexp -> regexp
  | atomic : X -> regexp.

  Notation " âŸª l âŸ«" := (atomic l).

  (** The size of an expression is the number of occurrences of variables appearing in it. *)
  Fixpoint sizeExpr e :=
    match e with
    | e_un | e_zero => 0
    | âŸª_âŸ« => 1
    | e_add e f | e_prod e f => sizeExpr e + sizeExpr f
    | e_star e => sizeExpr e
    end.

  (** We may associate to an expression [e] the regular language [âŸ¦eâŸ§]. *)
  Reserved Notation " âŸ¦ e âŸ§ ".
  Fixpoint reg_lang (e : regexp) : language :=
    match e with
    | e_un => ğŸ­
    | e_zero => ğŸ¬
    | e_prod e f => âŸ¦eâŸ§ Â· âŸ¦fâŸ§
    | e_add e f => âŸ¦eâŸ§ âˆª âŸ¦fâŸ§
    | e_star e => âŸ¦eâŸ§ â‹†
    | âŸª l âŸ« => fun w => w = [l]
    end
  where " âŸ¦ e âŸ§ " := (reg_lang e).

  (* begin hide *)
  Global Instance regUn : Un regexp := e_un.

  Global Instance regZero : Zero regexp :=e_zero.

  Global Instance regJoin : Join regexp := e_add.

  Global Instance regProduct : Product regexp :=e_prod.

  Global Instance regStar : Star regexp := e_star.
  (* end hide *)

  (** Given a set of identities [Ax] (i.e. a binary relation over
  expressions) and a set of quasi-equations [Ax'] (i.e. a quaternary
  relation), we define the relation [{| Ax , Ax' |} âŠ¢ e == f] as the
  smallest congruence stable by both [Ax] and [Ax']. *)
  Reserved Notation " {| Ax , Ax' |} âŠ¢ e == f " (at level 80).
  Inductive ax_eq (Ax : relation regexp) (Ax' : regexp -> regexp -> regexp -> regexp -> Prop)
    : relation regexp :=
  | ax_eq_refl e : {|Ax,Ax'|} âŠ¢ e == e
  | ax_eq_sym e f : {|Ax,Ax'|} âŠ¢ e == f -> {|Ax,Ax'|} âŠ¢ f == e
  | ax_eq_trans e f g : {|Ax,Ax'|} âŠ¢ e == f -> {|Ax,Ax'|} âŠ¢ f == g -> {|Ax,Ax'|} âŠ¢ e == g 
  | ax_eq_prod e f e' f' : {|Ax,Ax'|} âŠ¢ e == f -> {|Ax,Ax'|} âŠ¢ e' == f' -> {|Ax,Ax'|} âŠ¢ e Â· e' == f Â· f'
  | ax_eq_add e f e' f' : {|Ax,Ax'|} âŠ¢ e == f -> {|Ax,Ax'|} âŠ¢ e' == f' -> {|Ax,Ax'|} âŠ¢ e âˆª e' == f âˆª f'
  | ax_eq_star e f : {|Ax,Ax'|} âŠ¢ e == f -> {|Ax,Ax'|} âŠ¢ e â‹† == f â‹†
  | ax_eq_ax e f : Ax e f -> {|Ax,Ax'|} âŠ¢ e == f
  | ax_eq_ax' e f g h : Ax' e f g h -> {|Ax,Ax'|} âŠ¢ e == f -> {|Ax,Ax'|} âŠ¢ g == h
  where " {| Ax , Ax' |} âŠ¢ e == f " := (ax_eq Ax Ax' e f).

  Definition ax_inf Ax Ax' e f := {|Ax,Ax'|} âŠ¢ e âˆª f == f.
  Notation " {| Ax , Ax' |} âŠ¢ e =<= f " := (ax_inf Ax Ax' e f) (at level 80).
  
  Hint Constructors ax_eq.

  (** * Basic properties *)
  (** ** Properties of the language interpretation *)
  Lemma Î£_lang L u : âŸ¦Î£ LâŸ§ u <-> exists e, e âˆˆ L /\ âŸ¦eâŸ§ u.
  Proof.
    revert u;induction L;intros;simpl.
    - split;[intro F;exfalso;apply F|intros (?&?&_);tauto].
    - split.
      + intros [I|I].
        * exists a;tauto.
        * apply IHL in I as (e&Ie&Iu);exists e;tauto.
      + intros (e&[<-|Ie]&Iu);[left|right;apply IHL;exists e];tauto.
  Qed.

  Lemma split_star e u v :
    âŸ¦eâ‹†âŸ§ (u++v) ->
    (u=[] /\ v=[])
    \/ exists u1 u2 v1 v2, u = u1++u2 /\ v=v1++v2 /\ âŸ¦eâ‹†âŸ§ u1 /\ âŸ¦eâŸ§ (u2++v1) /\ âŸ¦eâ‹†âŸ§ v2.
  Proof.
    intros (n&In);revert u v In;induction n;intros u v;simpl.
    - intro E;apply app_eq_nil in E as (->&->);tauto.
    - intros (w1&w2&E&I1&I2);right.
      levi E;subst;clear E.
      + exists [],w1,[],w2;repeat split.
        * exists 0;reflexivity.
        * rewrite app_nil_r;assumption.
        * exists n;assumption.
      + apply (IHn (a::w) v) in I2 as [(F&_)|(u1&u2&v1&v2&E1&->&h1&h2&h3)];
          [discriminate|].
        replace (cons a) with (app [a]) in * by reflexivity.
        rewrite E1 in *;clear E1 a w.
        exists (w1++u1),u2,v1,v2;rewrite app_ass;repeat split;try assumption.
        destruct h1 as (N&I).
        exists (S N),w1,u1;tauto.
      + clear IHn.
        exists [],u,(a::w),w2;repeat split.
        * exists 0;reflexivity.
        * assumption.
        * exists n;assumption.
  Qed.

  (** ** Properties of the axiomatic equivalence *)  
  Global Instance ax_eq_Equivalence Ax Ax' : Equivalence (ax_eq Ax Ax').
  Proof.
    split.
    - intro e;auto.
    - intros e f;eauto.
    - intros e f g E1 E2;eauto.
  Qed.

  Global Instance prod_ax_eq Ax Ax' :
    Proper (ax_eq Ax Ax' ==> ax_eq Ax Ax' ==> ax_eq Ax Ax') prod.
  Proof. intros ? ? ? ? ? ?;eauto. Qed.

  Global Instance join_ax_eq Ax Ax' :
    Proper (ax_eq Ax Ax' ==> ax_eq Ax Ax' ==> ax_eq Ax Ax') join.
  Proof. intros ? ? ? ? ? ?;eauto. Qed.

  Global Instance star_ax_eq Ax Ax':
    Proper (ax_eq Ax Ax'==> ax_eq Ax Ax') star.
  Proof. intros ? ? ?;eauto. Qed.

  (** If the axioms [Ax,Ax'] are sound with respect to the language
  interpretation, so is the relation [{|Ax,Ax'|}âŠ¢_==_]. *)
  Remark soundness_proof (Ax: relation regexp)(Ax' : regexp -> regexp -> regexp -> regexp -> Prop):
    (forall e f, Ax e f -> âŸ¦eâŸ§ â‰ƒ âŸ¦fâŸ§) ->
    (forall e f g h, Ax' e f g h -> âŸ¦eâŸ§ â‰ƒ âŸ¦fâŸ§ -> âŸ¦gâŸ§ â‰ƒ âŸ¦hâŸ§) ->
    forall e f, {|Ax,Ax'|} âŠ¢ e == f -> âŸ¦eâŸ§ â‰ƒ âŸ¦fâŸ§.
  Proof.
    intros hyp1 hyp2 e f E;induction E.
    - reflexivity.
    - symmetry;assumption.
    - etransitivity;eassumption.
    - simpl;rewrite IHE1,IHE2;reflexivity.
    - simpl;rewrite IHE1,IHE2;reflexivity.
    - simpl;rewrite IHE;reflexivity.
    - apply hyp1;assumption.
    - eapply hyp2;eassumption.
  Qed.

  Section gen_proofs.
    Context {Ax : relation regexp}{Ax' : regexp -> regexp -> regexp -> regexp -> Prop}.

    (** A set of axioms is good enough if it entails that [âˆª] is
    idempotent, associative and commutative. *)
    Class GoodEnoughAxiom Ax :=
      {join_idem : forall e, Ax (e âˆª e) e;
       join_assoc : forall e f g, Ax (e âˆª (f âˆª g)) ((e âˆª f) âˆª g);
       join_comm : forall e f, Ax (e âˆª f) (f âˆª e)}.

    Context {G : GoodEnoughAxiom Ax}.

    (** In this case, we can show that [{|Ax,Ax'|} âŠ¢ e =<= f] is a
    partial order, thus yielding a semi-lattice structure. *)
    Global Instance ax_inf_PreOrder : PreOrder (fun e f => {|Ax,Ax'|} âŠ¢ e =<= f).
    Proof.
      destruct G as [h1 h2 h3];split.
      - intro e;apply ax_eq_ax;auto.
      - intros e f g E1 E2.
        unfold ax_inf in *.
        etransitivity;[|apply E2].
        rewrite <- E1;rewrite <- E2 at 1;apply ax_eq_ax;auto.
    Qed.

    Global Instance ax_inf_PartialOrder :
      PartialOrder (ax_eq Ax Ax') (fun e f => {|Ax,Ax'|} âŠ¢ e =<= f).
    Proof.
      destruct G as [h1 h2 h3];intros e f;split;unfold Basics.flip,ax_inf.
      - intro E;split.
        + rewrite E;auto.
        + rewrite E;auto.
      - intros (E1&E2).
        rewrite <- E1.
        rewrite <- E2 at 1;auto.
    Qed.
    
    Global Instance joinOrder_ax : JoinOrder _ (ax_eq Ax Ax') (ax_inf Ax Ax') join.
    Proof. intros x y;unfold ax_inf;split;intro h;symmetry;apply h. Qed.

    Lemma ax_eq_inf e f : {| Ax,Ax'|} âŠ¢ e == f -> {| Ax,Ax'|} âŠ¢ e =<= f.
    Proof. rewrite (ax_inf_PartialOrder e f);intros (H&_);tauto. Qed.

    Global Instance Semilattice_ax : Semilattice _ (ax_eq Ax Ax') join.
    Proof.
      split.
      - intros e f g;apply ax_eq_ax,join_assoc.
      - intros e f;apply ax_eq_ax,join_comm.
      - intro e;apply ax_eq_ax,join_idem.
    Qed.

    (** [Ax] is very good if in addition it entails distributivity of
    [Â·] over [âˆª]. *)
    Class VeryGoodAxioms Ax :=
      {left_distr : forall e f g, Ax (e Â· (f âˆª g))  (eÂ·f âˆª eÂ·g);
       right_distr : forall e f g, Ax ((e âˆª f)Â· g) (eÂ·g âˆª fÂ·g)}.

    Context {V : VeryGoodAxioms Ax}.

    (** In this case, the product preserves the ordering. *)
    Global Instance prod_ax_inf :
      Proper (ax_inf Ax Ax' ==> ax_inf Ax Ax' ==> ax_inf Ax Ax') prod.
    Proof.
      destruct V as (h1&h2);destruct G as [h3 h4 h5];intros e1 e2 E1 f1 f2 E2;unfold ax_inf in *.
      rewrite <-E2 at 2.
      transitivity (e2 Â· f1 âˆª e2 Â· f2);[|now auto].
      rewrite <- E1 at 2.
      transitivity ((e1 Â· f1 âˆª e2 Â· f1) âˆª e2 Â· f2);[|now auto].
      transitivity (e1 Â· f1 âˆª (e2 Â· f1 âˆª e2 Â· f2));[|now auto].
      transitivity (e1 Â· f1 âˆª e2 Â· (f1 âˆª f2));[|now auto].
      rewrite E2;reflexivity.
    Qed.

  End gen_proofs.

  (** * The axiomatization [KA]. *)
  Reserved Notation " e =KA f " (at level 80).
  Reserved Notation " e <=KA f " (at level 80).
  
  Inductive KA : relation regexp :=
  | KA_prod_assoc e f g : e Â· (f Â· g) =KA (e Â· f) Â· g
  | KA_add_assoc e f g : e âˆª (f âˆª g) =KA (e âˆª f) âˆª g
  | KA_add_comm e f : e âˆª f =KA f âˆª e
  | KA_left_distr e f g : e Â· (f âˆª g) =KA eÂ·f âˆª eÂ·g
  | KA_right_distr e f g : (e âˆª f)Â· g =KA eÂ·g âˆª fÂ·g
  | KA_zero e : ğŸ¬ <=KA e
  | KA_un_left e : ğŸ­ Â· e =KA e
  | KA_un_right e : e Â· ğŸ­ =KA e
  | KA_left_zero e : ğŸ¬ Â· e =KA ğŸ¬
  | KA_right_zero e : e Â· ğŸ¬ =KA ğŸ¬
  | KA_idem e : e <=KA e
  | KA_star_unfold e : ğŸ­ âˆª e Â· e â‹† <=KA eâ‹† 
  where " e =KA f " := (KA e f)
  and " e <=KA f " := (KA (e âˆª f) f).

  Hint Constructors KA.

  Inductive KA' : regexp -> regexp -> regexp -> regexp -> Prop :=
  | KA_star_left_ind e f : KA' (e Â· f âˆª f) f (e â‹† Â· f âˆª f) f
  | KA_star_right_ind e f : KA' (e Â· f âˆª e) e (e Â· f â‹† âˆª e) e.

  Hint Constructors KA'.
  
  Global Instance goodKA : GoodEnoughAxiom KA.
  Proof. split;intros;auto. Qed.
  Global Instance verygoodKA : VeryGoodAxioms KA.
  Proof. split;intros;auto. Qed.
  
  Lemma star_left_ind e f : {| KA,KA'|} âŠ¢ e Â· f =<= f -> {| KA,KA'|} âŠ¢ eâ‹† Â· f =<= f.
  Proof.
    intro h;eapply ax_eq_ax'.
    - apply KA_star_left_ind.
    - apply h.
  Qed.
  Lemma star_right_ind e f : {| KA,KA'|} âŠ¢ e Â· f =<= e -> {| KA,KA'|} âŠ¢ e Â· fâ‹† =<= e.
  Proof.
    intro h;eapply ax_eq_ax'.
    - apply KA_star_right_ind.
    - apply h.
  Qed.

  (** The set of expressions equipped with the axioms [KA,KA'] forms a Kleene algebra. *)
  Global Instance KA_regexp : KleeneAlgebra regexp (ax_eq KA KA') (ax_inf KA KA').
  Proof.
    split.
    - apply prod_ax_eq.
    - apply join_ax_eq.
    - apply star_ax_eq.
    - repeat split;intro;intros;eauto.
    - repeat split;intro;intros;eauto.
    - apply joinOrder_ax.
    - intros a;apply ax_eq_ax;auto.
    - apply star_left_ind. 
    - apply star_right_ind.
  Qed.
  Global Instance Semilattice_KA : Semilattice _ (ax_eq KA KA') join := join_semilattice.

  (** Axiomatic equivalence is sound with respect to the language interpretation. *)
  Proposition soundness e f : {|KA,KA'|} âŠ¢ e == f -> âŸ¦eâŸ§ â‰ƒ âŸ¦fâŸ§.
  Proof.
    apply soundness_proof;clear.
    - intros e f E;destruct E;simpl;try now apply lang_KA.
      + apply mon_assoc.
      + apply mon_assoc.
      + apply semiring_comm.
      + symmetry;apply join_is_order,ka_star_unfold.
    - intros e f g h E;destruct E;intro E;simpl in *;symmetry in E;
        rewrite <- join_is_order in E;symmetry;apply join_is_order.
      + apply ka_star_left_ind,E.
      + apply ka_star_right_ind,E.
  Qed.
  
  Lemma ax_inf_lang_incl e f : {| KA,KA' |} âŠ¢ e =<= f -> âŸ¦eâŸ§ â‰² âŸ¦fâŸ§.
  Proof.
    unfold ax_inf;rewrite join_is_order;intro I.
    transitivity âŸ¦eâˆªfâŸ§;[|reflexivity].
    apply soundness;symmetry;assumption.
  Qed.

  (** * Equatity modulo associativity, commutativity, idempotence and units. *)
  Inductive ACI0 : relation regexp :=
  | ACI0_prod_assoc e f g : ACI0(e Â· (f Â· g)) ((e Â· f) Â· g)
  | ACI0_add_assoc e f g : ACI0 (e âˆª (f âˆª g)) ((e âˆª f) âˆª g)
  | ACI0_add_comm e f : ACI0 (e âˆª f) (f âˆª e)
  | ACI0_add_idem e : ACI0 (e âˆª e) e
  | ACI0_add_zero e : ACI0 (e âˆª ğŸ¬) e
  | ACI0_prod_one e : ACI0 (ğŸ­ Â· e) e.
  Definition Empt : regexp -> regexp -> regexp -> regexp -> Prop := fun _ _ _ _ => False.
  Hint Constructors ACI0.

  Global Instance goodACI0 : GoodEnoughAxiom ACI0.
  Proof. split;intros;auto. Qed.

  Infix " â‰¡0 " := (ax_eq ACI0 Empt) (at level 80).
  Infix " â‰¦0 " := (ax_inf ACI0 Empt) (at level 80).
  
  Lemma KA_ACI0 e f : e â‰¡0 f -> {|KA,KA'|}âŠ¢e==f.
  Proof.
    intros E;induction E.
    - reflexivity.
    - symmetry;assumption.
    - etransitivity;eassumption.
    - rewrite IHE1,IHE2;reflexivity.
    - rewrite IHE1,IHE2;reflexivity.
    - rewrite IHE;reflexivity.
    - destruct H;auto.
      transitivity (ğŸ¬âˆªe);auto.
    - destruct H.
  Qed.
  
  (** * Utilities *)
  (** ** Variables *)
  (** [Var e] computes the set of variables appearing in [e]. *)
  Fixpoint Var (e : regexp) : list X :=
    match e with
    | e_un | e_zero => []
    | âŸªxâŸ« => [x]
    | e_prod e f | e_add e f => Var e ++ Var f
    | e_star e => Var e
    end.

  Lemma Var_spec e w : âŸ¦ e âŸ§ w -> w âŠ† Var e.
  Proof.
    revert w;induction e;intro w;simpl.
    - intro I;exfalso;apply I.
    - intros ->;reflexivity.
    - intros [I|I].
      + rewrite IHe1 by assumption;apply incl_appl;reflexivity.
      + rewrite IHe2 by assumption;apply incl_appr;reflexivity.
    - intros (u&v&->&Iu&Iv).
      apply IHe1 in Iu as ->.
      apply IHe2 in Iv as ->.
      reflexivity.
    - intros (n&I);revert w I;induction n.
      + intros w ->;apply incl_nil.
      + intros w (u&v&->&I1&I2).
        apply IHe in I1 as ->.
        apply IHn in I2 as ->.
        intro;simpl_In;tauto.
    - intros ->;reflexivity.
  Qed.

  (** ** Empty word *)
  (** [Ïµ e] yields [ğŸ­] if [âŸ¦eâŸ§] contains the empty word, [ğŸ¬] otherwise. *)
  Fixpoint Ïµ (e : regexp) : regexp :=
    match e with
    | e_un | e_star _ => e_un
    | e_zero | âŸª_âŸ« => e_zero
    | e_prod e f =>
      match (Ïµ e,Ïµ f) with
      | (e_un,e_un) => e_un
      | _ => e_zero
      end
    | e_add e f => 
      match (Ïµ e,Ïµ f) with
      | (e_un,_) | (_,e_un) => e_un
      | _ => e_zero
      end
    end.

  Lemma nil_prod_lang (l m : @language X) : (lÂ·m) [] <-> l [] /\ m [].
  Proof.
    split.
    - intros (u&v&e&h);symmetry in e;apply app_eq_nil in e as (->&->);assumption.
    - intros h;exists [],[];split;[reflexivity|assumption].
  Qed.

  Lemma Ïµ_zero_or_un e : {Ïµ e = e_un} + {Ïµ e = e_zero}.
  Proof.
    induction e;simpl;try tauto.
    - destruct IHe1 as [-> | ->] ;[|destruct IHe2 as [-> | ->]];tauto.
    - destruct IHe1 as [-> | ->] ;[destruct IHe2 as [-> | ->]|];tauto.
  Qed.
  
  Lemma Ïµ_spec e : Ïµ e = e_un <-> âŸ¦eâŸ§ [].
  Proof.
    induction e;simpl.
    - split;[discriminate|intro F;exfalso;apply F].
    - split;reflexivity.
    - destruct (Ïµ e1);tauto || destruct (Ïµ e2);
        try (split;[discriminate|intros [h|h];apply IHe1 in h||apply IHe2 in h;discriminate]);
        try (split;[intros _;(left;apply IHe1;reflexivity)
                             ||(right;apply IHe2;reflexivity)
                   |reflexivity]).
    - etransitivity;[|symmetry;apply nil_prod_lang].
      rewrite <- IHe1,<-IHe2;clear.
      split.
      + destruct (Ïµ e1);tauto || destruct (Ïµ e2);discriminate||tauto.
      + intros (-> & ->);reflexivity.
    - split;[|reflexivity].
      intros _;exists 0;reflexivity.
    - split;discriminate.
  Qed.

  Lemma Ïµ_inf_e e : {|KA,KA'|} âŠ¢ Ïµ e =<= e.
  Proof.
    induction e;simpl.
    - reflexivity.
    - reflexivity.
    - replace e_add with join by reflexivity.
      transitivity (Ïµ e1 âˆª Ïµ e2);[clear IHe1 IHe2|rewrite IHe1,IHe2;reflexivity].
      apply ax_eq_inf.
      destruct (Ïµ_zero_or_un e1) as [-> | ->]; try destruct (Ïµ_zero_or_un e2)as [-> | ->];eauto.
    - replace e_prod with prod by reflexivity.
      transitivity (Ïµ e1 Â· Ïµ e2);[clear IHe1 IHe2|rewrite IHe1,IHe2;reflexivity].
      apply ax_eq_inf.
      destruct (Ïµ_zero_or_un e1) as [-> | ->]; try destruct (Ïµ_zero_or_un e2)as [-> | ->];eauto.
    - apply one_inf_star.
    - replace e_zero with zero by reflexivity;apply zero_minimal.
  Qed.

  (** [Ïµ e] is [ğŸ­] exactly when the inequation [ğŸ­<=e] is provable in [KA]. *)
  Lemma Ïµ_ax_spec e : Ïµ e = un <-> {|KA,KA'|} âŠ¢ un =<= e.
  Proof.
    split.
    - intro E;etransitivity;[|apply Ïµ_inf_e].
      rewrite E;reflexivity.
    - intro E;apply Ïµ_spec.
      apply (ax_inf_lang_incl E);reflexivity.
  Qed.

  Lemma Ïµ_zero e : Ïµ e = e_zero <-> ~ âŸ¦eâŸ§ [].
  Proof.
    rewrite <- Ïµ_spec;destruct (Ïµ_zero_or_un e) as [-> | ->].
    - split;[discriminate|tauto].
    - split;[discriminate|reflexivity].
  Qed.

  Remark Ïµ_sub_id e : {|KA,KA'|} âŠ¢ Ïµ e =<= ğŸ­.
  Proof. destruct (Ïµ_zero_or_un e) as [-> | ->];unfold ax_inf; now auto. Qed.

  Lemma Ïµ_add e f :  {|KA,KA'|} âŠ¢ Ïµ (e âˆª f) == Ïµ e âˆª Ïµ f.
  Proof.
    simpl;destruct (Ïµ_zero_or_un e) as [-> | ->];destruct (Ïµ_zero_or_un f) as [-> | ->].
    - now auto.
    - transitivity (ğŸ¬âˆªğŸ­);now auto.
    - now auto.
    - now auto.
  Qed.
  
  Lemma Ïµ_prod e f :  {|KA,KA'|} âŠ¢ Ïµ (e Â· f) == Ïµ e Â· Ïµ f.
  Proof.
    simpl;destruct (Ïµ_zero_or_un e) as [-> | ->];destruct (Ïµ_zero_or_un f) as [-> | ->];now auto.
  Qed.

  Global Instance Ïµ_proper : Proper (ax_eq KA KA' ==> ax_eq KA KA') Ïµ.
  Proof.
    intros e f E;induction E;simpl;auto.
    - eauto.
    - revert IHE1 IHE2.
      destruct (Ïµ_zero_or_un e)
        as [-> | ->],
           (Ïµ_zero_or_un e')
          as [-> | -> ],
             (Ïµ_zero_or_un f)
            as [-> | ->],
               (Ïµ_zero_or_un f')
              as [-> | ->];auto.
    - revert IHE1 IHE2.
      destruct (Ïµ_zero_or_un e)
        as [-> | ->],
           (Ïµ_zero_or_un e')
          as [-> | -> ],
             (Ïµ_zero_or_un f)
            as [-> | ->],
               (Ïµ_zero_or_un f')
              as [-> | ->];auto.
    - destruct H;simpl;try destruct  (Ïµ_zero_or_un e) as [-> | ->];
        try destruct  (Ïµ_zero_or_un f) as [-> | ->];
        try destruct  (Ïµ_zero_or_un g) as [-> | ->];auto.
    - destruct H;revert IHE;simpl;try destruct  (Ïµ_zero_or_un e) as [-> | ->];
        try destruct  (Ïµ_zero_or_un f) as [-> | ->];auto.
  Qed.

  Global Instance Ïµ_proper_inf : Proper (ax_inf KA KA' ==> ax_inf KA KA') Ïµ.
  Proof.
    intros e f E.
    apply Ïµ_proper in E as <-.
    unfold ax_inf;simpl.
    destruct (Ïµ_zero_or_un e) as [-> | ->]; try destruct (Ïµ_zero_or_un f)as [-> | ->];auto.
  Qed.
    
  Lemma Ïµ_idem e : Ïµ (Ïµ e) = Ïµ e.
  Proof. destruct (Ïµ_zero_or_un e) as [-> | ->];reflexivity. Qed.

  Lemma Ïµ_KA e f : {|KA, KA'|}âŠ¢ e == f -> Ïµ e = Ïµ f.
  Proof.
    intro E;apply soundness in E.
    destruct (Ïµ_zero_or_un e) as [E1|E1];rewrite E1.
    - symmetry;apply Ïµ_spec,E,Ïµ_spec,E1.
    - symmetry;apply Ïµ_zero;rewrite <-(E []);apply Ïµ_zero,E1.
  Qed.
  
  (** ** Empty language *)
  (** [test0 e] is a boolean, it returns [true] if and only if the language of [e] is empty. *)
  Fixpoint test0 e :=
    match e with
    | e_zero => true
    | e_un | e_star _ | âŸª_âŸ« => false
    | e_add e f => test0 e && test0 f
    | e_prod e f => test0 e || test0 f
    end.

  Lemma test0_false e : test0 e = false -> exists u, âŸ¦eâŸ§ u.
  Proof.
    induction e;simpl.
    - discriminate.
    - intros _;exists [];reflexivity.
    - rewrite andb_false_iff;intros [h|h].
      + apply IHe1 in h as (u&I);exists u;now left.
      + apply IHe2 in h as (u&I);exists u;now right.
    - rewrite orb_false_iff;intros (h1&h2).
      apply IHe1 in h1 as (u1&I1);apply IHe2 in h2 as (u2&I2).
      exists (u1++u2),u1,u2;tauto.
    - intros _;exists [],0;reflexivity.
    - intros _;exists [x];reflexivity.
  Qed.

  (** [test0 e] is [true] exactly when the equation [e=ğŸ¬] is provable in [KA]. *)
  Lemma test0_spec e : test0 e = true <-> {|KA,KA'|} âŠ¢ e == e_zero.
  Proof.
    split.
    - induction e;simpl.
      + reflexivity.
      + discriminate.
      + rewrite andb_true_iff;intros (I1&I2);apply IHe1 in I1 as ->;apply IHe2 in I2 as ->.
        auto.
      + rewrite orb_true_iff;intros [I1|I2];[apply IHe1 in I1 as ->|apply IHe2 in I2 as ->];
          auto.
      + discriminate.
      + discriminate.
    - intros h;apply soundness in h.
      apply inf_lang_PartialOrder in h as (h&_).
      case_eq (test0 e);[reflexivity|].
      intro F;exfalso;apply test0_false in F as (u&F).
      apply (h u),F.
  Qed.

  Lemma test0_Î£ L :
    test0 (Î£ L) = forallb test0 L.
  Proof. induction L;simpl;congruence. Qed.

  
  Lemma test0_KA e f : {|KA, KA'|}âŠ¢ e == f -> test0 e = test0 f.
  Proof.
    intro E;apply eq_true_iff_eq.
    repeat rewrite test0_spec.
    rewrite E;tauto.
  Qed.

  Lemma test0_Ïµ e : test0 e = true -> test0 (Ïµ e) = true.
  Proof. repeat rewrite test0_spec;intro E;apply Ïµ_KA in E as ->;reflexivity. Qed.
      
  (** ** Unit language *)
  (** [test1 e] checks whether [e=ğŸ­] is provable in [KA]. If the value
  is [false], then [âŸ¦eâŸ§] is either the empty language or it contains a
  non-empty word [a::u]. *)
  Fixpoint test1 e :=
    match e with
    | e_zero => false
    | e_un => true
    | âŸª_âŸ« => false
    | e_star e => test1 e || test0 e
    | e_add e f => (test1 e && test1 f)||(test1 e && test0 f)||(test0 e && test1 f)
    | e_prod e f => test1 e && test1 f
    end.

  Lemma test0_test1_false e : test0 e = false -> test1 e = false -> exists a u, âŸ¦eâŸ§ (a::u).
  Proof.
    intros h1 h2;revert h2 h1.
    induction e;simpl;try discriminate;repeat rewrite orb_false_iff||rewrite andb_false_iff;firstorder.
    - apply test0_false in H1 as (v&I).
      exists x,(x0++v),(x::x0),v;tauto.
    - apply test0_false in H0 as ([|a v]&I).
      + exists x,x0,[],(x::x0);tauto.
      + exists a,(v++x::x0),(a::v),(x::x0);tauto.
    - exists x,x0,1,(x::x0),[].
      rewrite app_nil_r;simpl;repeat split;assumption.
    - exists x,[];reflexivity.
  Qed.
          
  
  Lemma test1_spec e : test1 e = true <-> {|KA,KA'|} âŠ¢ e == e_un.
  Proof.
    split.
    - induction e;simpl.
      + discriminate.
      + reflexivity.
      + repeat rewrite orb_true_iff; repeat rewrite andb_true_iff.
        repeat rewrite test0_spec;intros [[I|I]|I];destruct I as (I1&I2);
          try apply IHe1 in I1 as ->;try apply IHe2 in I2 as -> ;
          try rewrite I1;try rewrite I2;auto.
        transitivity (e_zero âˆª e_un);auto.
      + rewrite andb_true_iff;intros (I1&I2);apply IHe1 in I1 as ->;apply IHe2 in I2 as ->;auto.
      + rewrite orb_true_iff,test0_spec;intros [I|I].
        * apply IHe in I as ->.
          apply ax_inf_PartialOrder;unfold Basics.flip;split.
          -- rewrite <- (ax_eq_ax _ (KA_un_left _));apply star_right_ind.
             apply ax_eq_inf;auto.
          -- apply star_incr.
        * rewrite I;apply ka_zero_star.
      + discriminate.
    - intros h;apply soundness in h.
      case_eq (test1 e);[reflexivity|intro e1].
      case_eq (test0 e);intro e2.
      + apply test0_spec,soundness in e2.
        rewrite e2 in h.
        exfalso;apply (h []);reflexivity.
      + destruct (test0_test1_false e2 e1) as (a&u&I).
        apply h in I;discriminate.
  Qed.

  (** ** Finite sums *)
  Fixpoint join_list {A} f (E : list A) : regexp :=
    match E with
    | [] => ğŸ¬
    | x::E => (f x) âˆª (join_list f E)
    end.
  
  Notation "Î£_{ X } f" := (join_list f X) (at level 35).

  Lemma join_list_app {A} f (E F : list A) : Î£_{E++F} f â‰¡0 Î£_{E} f âˆª Î£_{F} f.
  Proof. induction E as [|e E];simpl;[|rewrite IHE];eauto. Qed.

  Lemma join_list_monotone {A} f (E F : list A) : E âŠ† F -> Î£_{E} f â‰¦0 Î£_{F} f.
  Proof.
    unfold ax_inf;induction E as [|e E];simpl.
    - eauto. 
    - intro L;rewrite <- IHE at 2 by (rewrite <- L;clear;intro;simpl;tauto).
      transitivity (e_add (f e) (e_add (join_list f E) (join_list f F)));[auto|].
      repeat rewrite <- join_list_app.
      assert (Ie : e âˆˆ (E++F)) by (simpl_In;rewrite <- L;simpl;tauto).
      clear L IHE;induction (E++F).
      + simpl in *;tauto.
      + destruct Ie as [<-|I].
        * simpl;transitivity ((f aâˆªf a)âˆª(join_list f l));now auto.
        * simpl;rewrite <- IHl at 2 by assumption.
          transitivity ((f eâˆªf a)âˆª(join_list f l));[now auto|].
          transitivity ((f a âˆª f e)âˆª(join_list f l));now auto.
  Qed.

  Lemma join_list_add {B} (A : list B) f g :
    Î£_{A} (fun x => f x âˆª g x) â‰¡0 Î£_{A} f âˆª Î£_{A} g.
  Proof.
    induction A;simpl.
    - now auto.
    - rewrite IHA;clear.
      transitivity (f a âˆª (g a âˆª (join_list f A âˆª join_list g A)));[now auto|].
      transitivity (f a âˆª ((g a âˆª join_list f A) âˆª join_list g A));[now auto|].
      transitivity (f a âˆª ((join_list f A âˆª g a) âˆª join_list g A));[now auto|].
      transitivity (f a âˆª (join_list f A âˆª (g a âˆª join_list g A)));[now auto|].
      now auto.
  Qed.

  Lemma join_list_left_distr {B} (A : list B) f e :
    {|KA,KA'|} âŠ¢ Î£_{A} (fun x => e Â· f x) == e Â· Î£_{A} f.
  Proof.
    induction A;simpl.
    - now auto.
    - rewrite IHA;now auto.
  Qed.
  
  Lemma join_list_right_distr {B} (A : list B) f e :
    {|KA,KA'|} âŠ¢ Î£_{A} (fun x => f x Â· e) == Î£_{A} f Â· e.
  Proof.
    induction A;simpl.
    - now auto.
    - rewrite IHA;now auto.
  Qed.
    
  Lemma join_list_equivalent {C} (A B : list C) f g :
    (forall x, x âˆˆ A -> {|KA,KA'|} âŠ¢ f x == g x) -> A â‰ˆ B ->
    {|KA,KA'|} âŠ¢ Î£_{A} f == Î£_{B} g.
  Proof.
    intros hypf hypA.
    transitivity (join_list g A).
    - revert hypf;clear;induction A.
      + reflexivity.
      + intros;simpl;rewrite IHA,hypf.
        * reflexivity.
        * simpl;tauto.
        * intros x Ix;apply hypf;now right.
    - apply KA_ACI0,ax_inf_PartialOrder;split;apply join_list_monotone;rewrite hypA;reflexivity.
  Qed.
  
  Lemma join_list_equivalent_ACI0 {C} (A B : list C) f g :
    (forall x, x âˆˆ A -> f x â‰¡0 g x) -> A â‰ˆ B -> Î£_{A} f â‰¡0 Î£_{B} g .
  Proof.
    intros hypf hypÎ£.
    transitivity (join_list g A).
    - revert hypf;clear;induction A.
      + reflexivity.
      + intros;simpl;rewrite IHA,hypf.
        * reflexivity.
        * simpl;tauto.
        * intros x Ix;apply hypf;now right.
    - apply ax_inf_PartialOrder;split;apply join_list_monotone;rewrite hypÎ£;reflexivity.
  Qed.
  
  Lemma join_list_zero {B} (A : list B) : Î£_{A} (fun _ => e_zero) â‰¡0 ğŸ¬.
  Proof. induction A;simpl;[|rewrite IHA];auto. Qed.

  Lemma Î£_app L M : Î£ L âˆª Î£ M â‰¡0 Î£ (L++M).
  Proof. induction L;simpl;[|rewrite <- IHL];eauto. Qed.
      
  Lemma Î£_incl0 L M : L âŠ† M -> Î£ L â‰¦0 Î£ M.
  Proof.
    unfold ax_inf;rewrite Î£_app;revert M;induction L;intros M I.
    - reflexivity.
    - simpl;rewrite IHL by (rewrite <- I;intro;simpl;tauto).
      assert (Ia : a âˆˆ M) by (apply I;now left).
      clear I L IHL.
      induction M as [|e L].
      + simpl in *;tauto.
      + simpl;destruct Ia as [->|Ia];simpl;
          replace e_add with join in * by reflexivity.
        * transitivity ((aâˆªa)âˆªÎ£ L);auto.
        * transitivity ((aâˆªe)âˆªÎ£ L);[auto|].
          transitivity ((eâˆªa)âˆªÎ£ L);[auto|].
          rewrite <- IHL at 2 by assumption;auto.
  Qed.  
  
  Global Instance Î£_equivalent : Proper (@equivalent _ ==> ax_eq ACI0 Empt) Î£.
  Proof.
    intros l1 l2 E.
    apply incl_PartialOrder in E as (E1&E2);unfold Basics.flip in E2.
    apply Î£_incl0 in E1; apply Î£_incl0 in E2;unfold ax_inf in *.
    rewrite <- E1,<- E2 at 1;auto.
  Qed.
  
  Lemma Î£_map_concat l :
    Î£ (map Î£ l) â‰¡0 Î£ (concat l).
  Proof.
    induction l;simpl.
    - reflexivity.
    - rewrite  <- Î£_app,IHl;reflexivity.
  Qed.

  Lemma Î£_map_equiv {A} (f g : A -> regexp) (L : list A) :
    (forall e, e âˆˆ L -> {| KA , KA' |} âŠ¢  f e == g e) -> {| KA , KA' |} âŠ¢ Î£ (map f L) == Î£ (map g L).
  Proof.
    intro hyp.
    induction L as [|e L].
    - reflexivity.
    - simpl;rewrite (hyp e) by (now left).
      apply ax_eq_add;[reflexivity|].
      apply IHL;intros;apply hyp;now right.
  Qed.
    
  Lemma Ïµ_Î£_un L : (exists e, e âˆˆ L /\ Ïµ e = un) -> Ïµ (Î£ L) = un.
  Proof.
    intros (e&Ie&Ee);induction L;simpl;[simpl in Ie;tauto|].
    destruct Ie as [->|Ie].
    - rewrite Ee;simpl;reflexivity.
    - destruct (Ïµ_zero_or_un a) as [-> | ->];[reflexivity|].
      rewrite (IHL Ie);reflexivity.
  Qed.

  Lemma Ïµ_Î£_zero L : (forall e, e âˆˆ L -> Ïµ e = zero) -> Ïµ (Î£ L) = zero.
  Proof.
    induction L;simpl;[reflexivity|].
    intros hyp;rewrite (hyp a) by (left;reflexivity).
    rewrite IHL;[reflexivity|].
    intros;apply hyp;now right.
  Qed.
  
  (** ** Finite products *)
  Definition Î  : list regexp -> regexp := fold_right prod un.
                                    
  Lemma Î _lang E u :
    âŸ¦Î  EâŸ§ u <-> exists U, u = fold_right (@app _) [] U
                   /\ â¢Uâ¥ = â¢Eâ¥
                   /\ forall n, âŸ¦nth n E unâŸ§ (nth n U []).
  Proof.
    revert u;induction E;intro u;simpl.
    - split.
      + intros -> ;exists [];split;[reflexivity|split;[reflexivity|]].
        intros [|n];reflexivity.
      + intros ([|]&->&h&h');[reflexivity|discriminate].
    - split.
      + intros (u1&u2&->&I1&I2).
        apply IHE in I2 as (U&E2&len&h).
        exists (u1::U);split;[|split].
        * rewrite E2;reflexivity.
        * simpl;rewrite len;reflexivity.
        * intros [|n];simpl;[assumption|].
          apply h.
      + intros ([|u1 U]&->&len&h);[discriminate|].
        exists u1,(fold_right (@app _) [] U);split;[reflexivity|].
        split;[apply (h 0)|].
        apply IHE;exists U;split;[reflexivity|].
        split;[simpl in *;lia|].
        intros n;apply (h (S n)).
  Qed.

  Lemma fold_star_prodList (e : regexp) l :
   {| KA , KA' |} âŠ¢  fold_right (fun f1 f2 => e_prod (e_prod e f1) f2) e l == Î  (pad e l).
  Proof.
    unfold pad,Î .
    induction l;simpl.
    - eauto.
    - rewrite IHl; clear IHl;simpl.
      replace e_prod with prod by reflexivity.
      auto.
  Qed.

  Remark idem_fold_star (g : regexp) P :
    âŸ¦fold_right (fun e f => g â‹† Â· e Â· f ) (g â‹†) PâŸ§ â‰ƒ âŸ¦g â‹† Â· fold_right (fun e f => g â‹† Â· e Â· f ) (g â‹†) PâŸ§.
  Proof.
    simpl;destruct P;simpl.
    - symmetry;apply (ka_star_dup âŸ¦gâŸ§).
    - repeat rewrite (mon_assoc _ _ _).
      rewrite ka_star_dup;reflexivity.
  Qed.

  (** * Derivatives*)
  (** From now on we assume that the alphabet [X] has decidable equality. *)
  Context {decX: decidable_set X }.

  (** This entails quite easily that the syntactic equality of regular
  expressions is decidable. *)
  Global Instance decidable_regexp : decidable_set regexp.
  Proof.
    Fixpoint eq_regexp e1 e2 :=
      match (e1,e2) with
      | (e_zero,e_zero) | (e_un,e_un) => true
      | (âŸªxâŸ«,âŸªyâŸ«) => x =?= y
      | (e_add e1 f1,e_add e2 f2) | (e_prod e1 f1,e_prod e2 f2) =>
                                    eq_regexp e1 e2 && eq_regexp f1 f2
      | (e_star e,e_star f) => eq_regexp e f
      | _  => false
      end.
    apply Build_decidable_set with (eqX:=eq_regexp).
    intros e f;apply iff_reflect;revert f;induction e;intros [| |f1 f2|f1 f2|f|y];simpl;
      try (split;discriminate||reflexivity).
    - rewrite andb_true_iff;rewrite <- IHe1,<-IHe2.
      split;[intro h;inversion h;split|intros (->&->)];reflexivity.
    - rewrite andb_true_iff;rewrite <- IHe1,<-IHe2.
      split;[intro h;inversion h;split|intros (->&->)];reflexivity.
    - rewrite <- IHe;split;[intro h;inversion h|intros ->];reflexivity.
    - unfold_eqX;[tauto|split;[intro h;inversion h;tauto|discriminate]].
  Qed.

  (** [Î´ x e] is the Brzozowski derivative of [e] at [x]. *)
  Fixpoint Î´ (x:X) (e : regexp) :=
    match e with
    | e_un | e_zero => e_zero
    | âŸªyâŸ« => if x =?= y
            then e_un
            else e_zero
    | e_prod e f =>
      if Ïµ e =?= ğŸ­
      then Î´ x e Â· f âˆª Î´ x f
      else Î´ x e Â· f
    | e_add e f => Î´ x e âˆª Î´ x f
    | e_star e => Î´ x e Â· eâ‹†
    end.

  
  Proposition fundamental_theorem e A :
    Var e âŠ† A -> {|KA,KA'|} âŠ¢ e == Ïµ e âˆª Î£_{A} (fun x => âŸªxâŸ« Â· Î´ x e).
  Proof.
    intro V;induction e.
    - simpl;clear.
      transitivity (ğŸ¬ âˆª ğŸ¬);[now auto|].
      apply ax_eq_add;[reflexivity|].
      rewrite join_list_right_distr;auto.
    - simpl;clear.
      rewrite join_list_right_distr;auto.
      transitivity (ğŸ¬ âˆª ğŸ­);[now auto|].
      transitivity (ğŸ­ âˆª ğŸ¬);now auto.
    - replace (e_add e1 e2) with (e1 âˆª e2) by reflexivity.
      simpl in V;apply incl_app_split in V.
      rewrite Ïµ_add.
      rewrite IHe1,IHe2 at 1 by tauto;clear.
      transitivity ((Ïµ e1 âˆª Ïµ e2) âˆª join_list (fun x : X => âŸª x âŸ« Â· Î´ x e1 âˆª âŸª x âŸ« Â· Î´ x e2) A).
      + rewrite (KA_ACI0 (join_list_add _ _ _)).
        apply refactor.
      + apply ax_eq_add;[reflexivity|].
        apply join_list_equivalent.
        * intros x _;simpl;auto.
        * reflexivity.
    - rewrite Ïµ_prod;simpl;replace e_prod with prod by reflexivity.
      simpl in V;apply incl_app_split in V.
      destruct V as (E1&E2);apply IHe1 in E1;apply IHe2 in E2;clear IHe1 IHe2.
      remember (join_list (fun x : X => âŸª x âŸ« Â· Î´ x e1) A) as f1.
      remember (join_list (fun x : X => âŸª x âŸ« Â· Î´ x e2) A) as f2.
      revert E1;destruct (Ïµ_zero_or_un e1) as [-> | ->];intros;simpl_eqX.
      + transitivity ((ğŸ­ Â· Ïµ e2) âˆª join_list (fun x : X => ((âŸª x âŸ« Â· Î´ x e1) Â· e2)
                                                             âˆª (âŸª x âŸ« Â· Î´ x e2)) A);
          [|apply ax_eq_add;[reflexivity|];apply join_list_equivalent;
            [intros x _;transitivity ((âŸª x âŸ« Â· (Î´ x e1 Â· e2)) âˆª (âŸª x âŸ« Â· Î´ x e2));auto|reflexivity]].
        rewrite (KA_ACI0 (join_list_add _ _ _)).
        rewrite join_list_right_distr.
        rewrite <- Heqf1,<-Heqf2.
        transitivity (Ïµ e2 âˆª (f2 âˆª f1 Â· e2));[|auto].
        transitivity ((Ïµ e2 âˆª f2) âˆª f1 Â· e2);[|auto].
        rewrite <- E2.
        transitivity ((ğŸ­ Â· e2) âˆª f1 Â· e2);[|auto].
        rewrite E1;auto.
      + transitivity ((ğŸ¬ Â· Ïµ e2) âˆª join_list (fun x : X => (âŸª x âŸ« Â· Î´ x e1) Â· e2) A);
          [|apply ax_eq_add;[reflexivity|];apply join_list_equivalent;
            [intros x _;transitivity (âŸª x âŸ« Â· (Î´ x e1 Â· e2));auto|reflexivity]].
        rewrite join_list_right_distr.
        rewrite <-Heqf1.
        rewrite E1.
        transitivity (ğŸ¬ Â· e2 âˆª f1 Â· e2);[auto|].
        transitivity (ğŸ¬ âˆª f1 Â· e2);auto.
    - apply ax_inf_PartialOrder;
        cut ( {|KA, KA'|}âŠ¢ join_list (fun x : X => âŸª x âŸ« Â· Î´ x (e â‹†)) A
              ==join_list (fun x : X => (âŸª x âŸ« Â· Î´ x e) Â· e â‹†) A);
        [intro E;unfold Basics.flip;split;rewrite E;clear E|].
      + replace e_star with star by reflexivity.
        replace (Ïµ (eâ‹†)) with ğŸ­ by reflexivity.
        apply IHe in V;clear IHe.
        cut ({|KA, KA'|}âŠ¢ eâ‹† =<= ( ğŸ­ âˆª join_list (fun x => (âŸª x âŸ« Â· Î´ x e) Â· e â‹†) A) Â·e â‹†).
        * intros ->; apply star_right_ind.
          rewrite join_list_right_distr.
          transitivity  (ğŸ­Â·e âˆª (join_list (fun x : X => âŸª x âŸ« Â· Î´ x e) A Â· e â‹†)Â· e);
            [apply ax_eq_inf;now auto|].
          apply inf_join_inf.
          -- transitivity e;[apply ax_eq_inf;now auto|].
             rewrite V at 1.
             apply proper_join_inf.
             ++ apply Ïµ_sub_id.
             ++ rewrite <- one_inf_star,right_unit;reflexivity.
          -- etransitivity;[|apply inf_cup_right].
             rewrite <- (mon_assoc _ _ _).
             apply proper_prod_inf;[reflexivity|].
             rewrite (star_incr e) at 2;rewrite ka_star_dup;reflexivity.
        * transitivity (ğŸ­Â·eâ‹†);[apply ax_eq_inf;now auto|].
          apply prod_ax_inf;[|reflexivity].
          apply inf_cup_left.
      + etransitivity;[|apply ax_eq_inf;symmetry;apply ka_star_unfold_eq].
        apply proper_join_inf;[reflexivity|].
        rewrite join_list_right_distr.
        apply proper_prod_inf;[|reflexivity].
        rewrite (IHe V).
        apply inf_cup_right.
      + apply join_list_equivalent;[|reflexivity].
        now intros x _;simpl;repeat rewrite prod'_prod;auto.
    - assert (E: A â‰ˆ x :: (rm x A)).
      + intro z;simpl_In.
        rewrite rm_In.
        destruct_eqX x z.
        * split;[tauto|].
          intros _;apply V;now left.
        * tauto.
      + transitivity (Ïµ âŸª x âŸ« âˆª join_list (fun x0 : X => âŸª x0 âŸ« Â· Î´ x0 âŸª x âŸ«) (x::Aâˆ–x)).
        * transitivity (ğŸ¬âˆªâŸªxâŸ«);[now auto|].
          transitivity (âŸªxâŸ«âˆªğŸ¬);[now auto|].
          transitivity (ğŸ¬âˆª(âŸªxâŸ«âˆªğŸ¬));[now auto|].
          simpl;apply ax_eq_add;[reflexivity|].
          repeat rewrite prod'_prod||rewrite join'_join; apply ax_eq_add;[simpl;simpl_beq;now auto|].
          rewrite <- (KA_ACI0 (join_list_zero (A âˆ– x))) at 1;apply join_list_equivalent;[|reflexivity].
          intros y I.
          apply rm_In in I as (I&N).
          simpl_beq;auto.
        * apply join_ax_eq;[reflexivity|].
          apply join_list_equivalent;[|symmetry;apply E].
          intros;reflexivity.
  Qed.

  Lemma Î´_lang e a w : âŸ¦eâŸ§ (a::w) <-> âŸ¦Î´ a eâŸ§ w.
  Proof.
    revert a w;induction e as [| |e IHe f IHf |e IHe f IHf |e|x];intros y w;simpl.
    - tauto.
    - split;[discriminate|intro F;exfalso;apply F].
    - unfold join,joinLang;rewrite IHe,IHf;tauto.
    - split.
      + intros (u&v&E&Iu&Iv).
        destruct u as [|? u].
        * simpl in E;subst.
          apply Ïµ_spec in Iu as ->;simpl_beq.
          right;apply IHf,Iv.
        * apply IHe in Iu;inversion E;subst;clear E.
          unfold_eqX;[left|];exists u,v;tauto.
      + unfold_eqX;[intros [(u&v&->&Iu&Iv)|Iw]|intros (u&v&->&Iu&Iv)];
          apply IHe in Iu || apply IHf in Iw.
        * exists (y::u),v;tauto.
        * exists [],(y::w);rewrite <- Ïµ_spec;tauto.
        * exists (y::u),v;tauto.
    - unfold join,joinLang,prod,prodLang;setoid_rewrite <- IHe;clear IHe;split.
      + intros (n&In).
        revert y w In;induction n;intros.
        * simpl in In;discriminate.
        * destruct In as ([|x u]&v&E&Iu&Iv).
          -- simpl in E;subst;apply IHn,Iv.
          -- clear IHn;inversion E;subst;clear E.
             exists u,v;repeat split;[|exists n];assumption.
      + intros (u&v&->&Iu&n&Iv).
        exists (S n),(y::u),v;tauto.
    - unfold_eqX;simpl;split.
      + destruct w;[reflexivity|discriminate].
      + intros ->;reflexivity.
      + intro E;apply N;inversion E;reflexivity.
      + intro F;exfalso;apply F.
  Qed.

  Lemma Î´_inf_e a e : {| KA , KA' |} âŠ¢ âŸªaâŸ« Â· (Î´ a e) =<= e.
  Proof.
    assert (E: Var e âŠ† a::Var e) by (intro;simpl;tauto).
    apply fundamental_theorem in E.
    etransitivity;[|apply ax_eq_inf;symmetry;apply E].
    etransitivity;[|apply inf_cup_right].
    apply inf_cup_left.
  Qed.

  Lemma Î´_Î£ l L : Î´ l (Î£ L) = Î£ (map (Î´ l) L).
  Proof.
    induction L;[reflexivity|].
    simpl;rewrite IHL;reflexivity.
  Qed.
  
  Lemma Î´_proper_KA l :
    Proper ((ax_eq KA KA') ==> (ax_eq KA KA')) (Î´ l).
  Proof.
    intros e1 e2 E;induction E.
    - reflexivity.
    - symmetry;assumption.
    - etransitivity;eassumption.
    - simpl;unfold_eqX.
      + rewrite IHE1,IHE2,E2;reflexivity.
      + exfalso.
        apply soundness in E1;apply Ïµ_spec,E1,Ïµ_spec in E.
        apply N,E.
      + exfalso.
        apply soundness in E1;apply Ïµ_spec,E1,Ïµ_spec in E.
        apply N,E.
      + rewrite IHE1,E2;reflexivity.
    - simpl;rewrite IHE1,IHE2;reflexivity.
    - simpl;rewrite IHE,E;reflexivity.
    - destruct H;simpl.
      + unfold_eqX;simpl.
        * rewrite (ax_eq_ax _ (KA_right_distr _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_add_assoc _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          reflexivity.
        * exfalso;revert E0 N;simpl.
          destruct (Ïµ_zero_or_un f) as [-> | ->];[tauto|discriminate].
        * rewrite (ax_eq_ax _ (KA_right_distr _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_add_assoc _ _ _)).
          repeat rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          reflexivity.
        * exfalso;revert E N;simpl.
          destruct (Ïµ_zero_or_un e) as [-> | ->];[tauto|discriminate].
        * repeat rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _));reflexivity.
      + apply ax_eq_ax;auto.
      + apply ax_eq_ax;auto.
      + unfold_eqX;repeat rewrite (ax_eq_ax _ (KA_right_distr _ _ _))
                   || rewrite (ax_eq_ax _ (KA_left_distr _ _ _))
                   || rewrite (ax_eq_ax _ (KA_add_assoc _ _ _))
                   || rewrite (ax_eq_ax _ (KA_prod_assoc _ _ _)).
        * apply ax_eq_add;[|reflexivity].
          rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)), <- (ax_eq_ax _ (KA_add_assoc _ _ _)).
          apply ax_eq_add;[reflexivity|].
          apply ax_eq_ax;auto.
        * reflexivity.
      + destruct (Ïµ_zero_or_un e) as [-> | ->];destruct (Ïµ_zero_or_un f) as [-> | ->];simpl_eqX;
          repeat rewrite (ax_eq_ax _ (KA_right_distr _ _ _))
          || rewrite (ax_eq_ax _ (KA_left_distr _ _ _))
          || rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _));
          (apply ax_eq_add;[reflexivity|]);[|now auto |now auto|now auto].
        transitivity (Î´ l f Â· g âˆª (Î´ l gâˆªÎ´ l g));[now auto|].
        transitivity ((Î´ l f Â· g âˆª Î´ l g)âˆªÎ´ l g);[now auto|].
        transitivity ((Î´ l g âˆª Î´ l f Â· g)âˆªÎ´ l g);[now auto|].
        auto.
      + apply ax_eq_ax,KA_zero.
      + simpl_eqX.
        transitivity ((ğŸ¬Â·e)âˆªÎ´ l e);[reflexivity|].
        transitivity (ğŸ¬âˆªÎ´ l e);[now auto|].
        apply ax_eq_ax;auto.
      + unfold_eqX.
        * replace e_zero with zero by reflexivity.
          transitivity (Î´ l e âˆª zero);[now auto|].
          transitivity (zero âˆª Î´ l e);now auto.
        * auto.
      + simpl_eqX.
        replace e_zero with zero by reflexivity.
        auto.
      + unfold_eqX.
        * transitivity (Î´ l e Â· zero âˆª zero);[now auto|].
          transitivity zero;[|now auto].
          transitivity (zero âˆª zero);auto.
        * transitivity zero;now auto.
      + auto.
      + replace e_zero with zero by reflexivity.
        rewrite (ax_eq_ax _ (KA_zero _)).
        unfold_eqX;[|now auto].
        transitivity (Î´ l e Â· eâ‹† âˆª Î´ l e Â· eâ‹†);now auto.   
    - destruct H;simpl in *;revert IHE;simpl_eqX;unfold_eqX;intros IHE.
      + rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)) in IHE.
        rewrite (ax_eq_ax _ (KA_idem _)) in IHE.
        cut ({|KA, KA'|}âŠ¢eâ‹†Â·f =<= f).
        * intro L.
          rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)).
          rewrite (ax_eq_ax _ (KA_idem _)).
          cut ({|KA, KA'|}âŠ¢(Î´ l e Â· e â‹†) Â· f =<= Î´ l f);[intro H;apply H|].
          rewrite <- (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          rewrite L.
          apply IHE.
        * eapply ax_eq_ax';[|apply E].
          auto.
      + cut ({|KA, KA'|}âŠ¢eâ‹†Â·f =<= f).
        * intro L.
          rewrite <- (ax_eq_ax _ (KA_add_assoc _ _ _)).
          rewrite (ax_eq_ax _ (KA_idem _)).
          cut ({|KA, KA'|}âŠ¢(Î´ l e Â· e â‹†) Â· f =<= Î´ l f);[intro H;apply H|].
          rewrite <- (ax_eq_ax _ (KA_prod_assoc _ _ _)).
          rewrite L.
          apply IHE.
        * eapply ax_eq_ax';[|apply E].
          auto.
      + cut ({|KA, KA'|}âŠ¢Î´ l e Â· f â‹† âˆª Î´ l f Â· f â‹† =<= Î´ l e);[intro H;apply H|].
        transitivity (Î´ l e Â· f â‹† âˆª Î´ l e Â· f â‹†).
        * apply proper_join_inf;[reflexivity|].
           apply proper_prod_inf;[|reflexivity].
           etransitivity;[|apply IHE].
           apply inf_cup_right.
        * rewrite (ax_eq_ax _ (KA_idem _)).
           eapply ax_eq_ax';[apply KA_star_right_ind|].
           cut ({|KA, KA'|}âŠ¢Î´ l e Â· f =<= Î´ l e);[intro H;apply H|].
           transitivity (Î´ l e Â· f âˆª Î´ l f);[apply inf_cup_left|apply IHE].
      + cut ({|KA, KA'|}âŠ¢Î´ l e Â· f â‹† =<= Î´ l e);[intro H;apply H|].
        eapply ax_eq_ax';[apply KA_star_right_ind|].
        cut ({|KA, KA'|}âŠ¢Î´ l e Â· f =<= Î´ l e);[intro H;apply H|apply IHE].
  Qed.

  Lemma Î´_proper_KA_inf l :
    Proper ((ax_inf KA KA') ==> (ax_inf KA KA')) (Î´ l).
  Proof.
    intros e1 e2 E.
    apply Î´_proper_KA with (l:=l) in E.
    simpl in E;apply E.
  Qed.

  Lemma test0_Î´ x e : test0 e = true -> test0 (Î´ x e) = true.
  Proof.
    induction e;simpl;try reflexivity||discriminate.
    - rewrite andb_true_iff;intros (T1&T2);rewrite IHe1,IHe2;tauto.
    - destruct (Ïµ_zero_or_un e1) as [E|E];rewrite orb_true_iff;intros [T|T].
      + apply test0_Ïµ in T;rewrite E in T;discriminate.
      + rewrite E;simpl_eqX;simpl.
        rewrite IHe2,T,orb_true_r;tauto.
      + rewrite E;simpl_eqX;simpl.
        rewrite IHe1;tauto.
      + rewrite E;simpl_eqX;simpl.
        rewrite T,orb_true_r;tauto.
  Qed.

  Remark Î´_prod l e f : {|KA, KA'|}âŠ¢ Î´ l (eÂ·f) == Î´ l e Â·f âˆª Ïµ eÂ·Î´ l f.
  Proof.
    simpl;destruct (Ïµ_zero_or_un e) as [-> | ->];simpl_eqX.
    - replace e_un with un by reflexivity.
      etransitivity;[|apply proper_join;[reflexivity|symmetry;apply left_unit]].
      reflexivity.
    - replace e_zero with zero by reflexivity.
      etransitivity;[|apply proper_join;[reflexivity|symmetry;apply left_absorbing]].
      etransitivity;[|symmetry;apply right_unit].
      reflexivity.
  Qed.

  (** [Î´] may be extended to words in the obvious way. *)
  Fixpoint Î´_words w e :=
    match w with
    | [] => e
    | a::w => Î´_words w (Î´ a e)
    end.

  Notation " Î´â‹† " := Î´_words.

  Lemma Î´_words_zero w : Î´â‹† w e_zero = e_zero.
  Proof.
    induction w;simpl.
    - reflexivity.
    - rewrite IHw ;reflexivity.
  Qed.

  Lemma Î´_words_add e f w : Î´â‹† w (e âˆª f) = (Î´â‹† w e) âˆª (Î´â‹† w f).
  Proof.
    revert e f;induction w as [|a w];intros e f;simpl;[reflexivity|].
    rewrite <- IHw;f_equal;clear;destruct e,f;unfold join';simpl;try reflexivity.
  Qed.

  Lemma Î´_words_lang e : âŸ¦ e âŸ§ â‰ƒ (fun w => Ïµ (Î´â‹† w e) = ğŸ­).
  Proof.
    intro w;revert e;induction w;intro e;simpl.
    - symmetry;apply Ïµ_spec.
    - rewrite Î´_lang,IHw;reflexivity.
  Qed.

  Lemma Î´_words_last e u a : Î´â‹† (u++[a]) e = Î´ a (Î´â‹† u e).
  Proof.
    revert e;induction u;intro e;simpl;[reflexivity|apply IHu].
  Qed.

  (** * Prefixes of a regular language *)
  Fixpoint prefixes e :=
    match e with
    | e_zero => []
    | e_un => [ğŸ­]
    | âŸªxâŸ« => [ğŸ­;âŸªxâŸ«]
    | e_add e f => prefixes e ++ prefixes f
    | e_prod e f => if test0 e || test0 f
                   then []
                   else prefixes e ++ map (prod e) (prefixes f)
    | e_star e =>  if test0 e
                  then [ğŸ­]
                  else map (prod (eâ‹†)) (prefixes e)
    end.

  Lemma prefixes_spec e : forall u, âŸ¦Î£ (prefixes e)âŸ§ u <-> exists v, âŸ¦eâŸ§ (u++v).
  Proof.
    induction e;intro u;simpl.
    - split;[intros I|intros (v&I)];exfalso;apply I.
    - split.
      + intros [->|I];[|exfalso;apply I].
        exists [];reflexivity.
      + intros (v&I);apply app_eq_nil in I as (->&->).
        left;reflexivity.
    - rewrite <- (soundness (KA_ACI0 (Î£_app (prefixes e1) (prefixes e2))) u);simpl.
      Transparent joinLang.
      unfold join at 1,joinLang;simpl.
      rewrite IHe1,IHe2;clear IHe1 IHe2.
      firstorder.
      Opaque joinLang.
    - case_eq (test0 e1 || test0 e2).
      + intro h;simpl.
        split;[intro I;exfalso;apply I|].
        intros (v&w1&w2&_&I1&I2).
        apply orb_true_iff in h as [h|h];apply test0_spec,soundness in h.
        * apply h in I1;apply I1.
        * apply h in I2;apply I2.
      + intros F.
        rewrite <- (soundness (KA_ACI0 (Î£_app (prefixes e1) _)) u);simpl.
        Transparent joinLang.
        unfold join at 1,joinLang;simpl.
        rewrite <- (soundness (Î£_distr_l _ _) u);simpl.
        rewrite IHe1;clear IHe1.
        split.
        * intros [(v&Iv)|(u1&u2&->&I1&I2)].
          -- apply orb_false_iff in F as (_&F);apply test0_false in F as (w&Iw).
             exists (v++w),(u++v),w;rewrite app_ass;tauto.
          -- apply IHe2 in I2 as (v&I2);exists v,u1,(u2++v);rewrite app_ass;tauto.
        * intros (v&w1&w2&E&I1&I2).
          levi E;subst;clear E.
          -- left;exists [];rewrite app_nil_r;tauto.
          -- right;exists w1,(a::w);split;[reflexivity|];split;[assumption|].
             apply IHe2;exists v;apply I2.
          -- left;exists (a::w);apply I1.
             Opaque joinLang.
    - case_eq (test0 e).
      + intro h;simpl.
        apply test0_spec,soundness in h.
        split;[intros [->|I];[exists[],0;reflexivity|exfalso;apply I]|].
        intros (v&[|n]&I);[apply app_eq_nil in I as (->&_);left;reflexivity|].
        destruct I as (u1&_&_&I&_).
        exfalso;apply h in I;apply I.
      + intros F.
        rewrite <- (soundness (Î£_distr_l _ _) u);simpl;split.
        * intros (u1&u2&->&(n&In)&I).
          apply IHe in I as (v&I).
          exists v,(S n);apply iter_lang_last.
          rewrite app_ass;exists u1,(u2++v);tauto.
        * intros (v&n&I);revert v I;induction n;intros v I.
          -- apply app_eq_nil in I as (->&_).
             exists [],[];split;[reflexivity|].
             split;[exists 0;reflexivity|].
             apply IHe;apply test0_false in F as (w&Iw);exists w;apply Iw.
          -- apply iter_lang_last in I as (u1&u2&E&I1&I2).
             levi E;subst;clear E.
             ++ exists u1,[];rewrite app_nil_r.
                split;[reflexivity|];split;[exists n;apply I1|].
                apply IHe;exists u2;apply I2.
             ++ exists u1,(a::w);split;[reflexivity|].
                split;[exists n;apply I1|].
                apply IHe;exists v;apply I2.
             ++ apply (IHn (a::w)),I1.
    - split.
      + intros [->|[->|F]].
        * exists [x];reflexivity.
        * exists [];reflexivity.
        * exfalso;apply F.
      + intros (v&E);destruct u as [|y[|z u]];simpl in *;inversion E;subst.
        * left;reflexivity.
        * right;left;reflexivity.
  Qed.

  Lemma test0_prefixes e : test0 e = true -> prefixes e = [].
  Proof.
    induction e;simpl;firstorder (try discriminate).
    - apply andb_true_iff in H as (h1&h2).
      rewrite IHe1,IHe2 by assumption.
      reflexivity.
    - rewrite H;reflexivity.
  Qed.

End regexp.

Notation "Î£_{ X } f" := (join_list f X) (at level 35).
Notation " âŸª l âŸ«" := (atomic l).

Notation " âŸ¦ e âŸ§ " := (reg_lang e).

Notation " {| Ax , Ax' |} âŠ¢ e == f " := (ax_eq Ax Ax' e f) (at level 80).

Notation " {| Ax , Ax' |} âŠ¢ e =<= f " := (ax_inf Ax Ax' e f) (at level 80).
Hint Constructors ax_eq.
Hint Constructors KA.
Hint Constructors KA'.
Notation " e =KA f " := (ax_eq KA KA' e f) (at level 80).
Notation " e <=KA f " := (ax_inf KA KA' e f) (at level 80).
Notation " Î´â‹† " := Î´_words.

Section Antimirov.
  Context {X : Set}{decX: decidable_set X }.

  (** * Antimirov derivatives *)
  
  Fixpoint Î´A a e :=
    match e with
    | e_zero | e_un => []
    | âŸª b âŸ« => if a =?= b then [e_un] else []
    | e_add e f => Î´A a e ++ Î´A a f
    | e_prod e f =>
      map (fun g => g Â· f) (Î´A a e)++(if Ïµ e =?= e_un then (Î´A a f) else [])
    | e_star e => map (fun g => g Â· eâ‹†) (Î´A a e)
    end.

  Fixpoint stateSpace (e:@regexp X) :=
    e::match e with
       | e_zero => []
       | e_un => []
       | âŸª x âŸ« => [e_un]
       | e_add e f => (stateSpace e) ++ (stateSpace f)
       | e_prod e f => map (fun g => g Â· f) (stateSpace e)++(if negb (test0 e) then stateSpace f else [])
       | e_star e => map (fun g => g Â· eâ‹†) (stateSpace e)
       end.

  Lemma stateSpace_refl e : e âˆˆ stateSpace e.
  Proof. destruct e;now left. Qed.

  Lemma test0_stateSpace e f :
    test0 f = true -> e âˆˆ stateSpace f -> test0 e = true.
  Proof.
    revert e;induction f;intro e;simpl;simpl_In;
      repeat rewrite andb_true_iff||rewrite orb_true_iff.
    - intros _ [<-|F];[reflexivity|tauto].
    - discriminate.
    - intros (IH1&IH2) [<-|[I|I]].
      + simpl;rewrite IH1,IH2;reflexivity.
      + apply IHf1;assumption.
      + apply IHf2;assumption.
    - intros [T|T] [<-|[I|I]];simpl.
      + rewrite T;reflexivity.
      + apply in_map_iff in I as (g&<-&Ig);simpl.
        rewrite (IHf1 _ T Ig);reflexivity.
      + rewrite T in I;simpl in I;tauto.
      + rewrite T,orb_true_r;reflexivity.
      + apply in_map_iff in I as (g&<-&Ig);simpl.
        rewrite T,orb_true_r;reflexivity.
      + destruct (test0 f1);simpl in I;[tauto|].
        apply (IHf2 _ T I).
    - discriminate.
    - discriminate.
  Qed.

  Lemma stateSpace_trans e f :
    f âˆˆ stateSpace e -> stateSpace f âŠ† stateSpace e.
  Proof.
    revert f;induction e;simpl;intros f;try tauto.
    - intros [<-|F];[reflexivity|tauto].
    - intros [<-|F];[reflexivity|tauto].
    - simpl_In;intros [<-|[If|If]];[reflexivity|apply IHe1 in If as ->|apply IHe2 in If as ->];
        apply incl_tl.
      + apply incl_appl;reflexivity.
      + apply incl_appr;reflexivity.
    - intros [<-|I];[reflexivity|revert I].
      simpl_In;repeat rewrite in_map_iff.
      intros [(f'&<-&I)|I].
      + apply IHe1 in I.
        intros g;simpl;simpl_In;repeat rewrite in_map_iff.
        intros [<-|[(g'&<-&Ig)|Ig]].
        * right;left;exists f';split.
          -- reflexivity.
          -- apply I,stateSpace_refl.
        * right;left;exists g';split.
          -- reflexivity.
          -- apply I,Ig.
        * revert Ig;case_eq (test0 f');simpl;[tauto|].
          case_eq (test0 e1);simpl;[|tauto].
          intros T1 T2;exfalso.
          cut (test0 f' = true);[intros E;rewrite E in T2;discriminate|].
          apply (test0_stateSpace T1).
          apply I,stateSpace_refl.
      + revert I; case_eq (test0 e1);simpl;[tauto|].
        intros _ I; apply IHe2 in I as ->;intro;simpl_In;tauto.
    - intros [<-|I];[reflexivity|revert I].
      rewrite in_map_iff;intros (f'&<-&I).
      apply IHe in I;intro g;simpl.
      simpl_In;repeat rewrite in_map_iff.
      intros [<-|[(g'&<-&Ig')|Ig]].
      + right;exists f';split;[reflexivity|].
        apply I,stateSpace_refl.
      + right;exists g';split;[reflexivity|].
        apply I,Ig'.
      + revert Ig.
        destruct (test0 f');simpl;[tauto|].
        rewrite in_map_iff;intros [<-|(g'&<-&Ig')].
        * left;reflexivity.
        * right;exists g';split;[reflexivity|].
          apply Ig'.
    - intros [<-|[<-|F]];[reflexivity| |tauto].
      intros ? [<-|F];[|simpl in F;tauto].
      now right;left.
  Qed.


  Lemma Î´A_stateSpace e a : Î´A a e âŠ† stateSpace e.
  Proof.
    induction e;simpl;apply incl_tl;try reflexivity.
    - rewrite IHe1,IHe2;apply reflexivity.
    - case_eq (test0 e1);intro T;simpl.
      + rewrite app_nil_r.
        unfold_eqX.
        * exfalso.
          apply Ïµ_spec in E.
          apply test0_spec,soundness in T.
          apply T in E;apply E.
        * rewrite app_nil_r.
          rewrite <- IHe1;reflexivity.
      + rewrite <- IHe1,<-IHe2.
        apply incl_app_Proper;[reflexivity|].
        destruct (Ïµ e1 =?= e_un);[reflexivity|apply incl_nil].
    - rewrite IHe;reflexivity.
    - destruct_eqX a x;[reflexivity|apply incl_nil].
  Qed.
  
  Lemma Antimirov_lang e a w : âŸ¦eâŸ§ (a::w) <-> exists f, f âˆˆ Î´A a e /\ âŸ¦fâŸ§ w.
  Proof.
    revert w;induction e;intro w;simpl;split.
    - intro F;exfalso;apply F.
    - firstorder.
    - intro F;discriminate.
    - firstorder.
    - intros [I|I].
      + apply IHe1 in I as (f&If);exists f;simpl_In;tauto.
      + apply IHe2 in I as (f&If);exists f;simpl_In;tauto.
    - intros (f&If&Iw);simpl_In in If;destruct If as [If|If].
      + left;apply IHe1;exists f;tauto.
      + right;apply IHe2;exists f;tauto.
    - intros ([|b u]&v&E&I1&I2).
      + apply Ïµ_spec in I1 as ->;simpl_beq.
        simpl in E;subst.
        apply IHe2 in I2 as (f&If&Iw).
        exists f;simpl_In;tauto.
      + simpl in E;inversion E;subst;clear E.
        apply IHe1 in I1 as (f&If&Iw).
        exists (fÂ·e2);split.
        * simpl_In;left;apply in_map_iff;exists f;tauto.
        * exists u,v;tauto.
    - intros (f&If&Iw);simpl_In in If;destruct If as [If|If].
      + apply in_map_iff in If as (f'&<-&If).
        destruct Iw as (u1&u2&->&I1&I2).
        exists (a::u1),u2;repeat split.
        * apply IHe1;exists f';tauto.
        * assumption.
      + destruct_eqX (Ïµ e1) (@e_un X);[|exfalso;apply If].
        exists [],(a::w);repeat split.
        * apply Ïµ_spec,E.
        * apply IHe2;exists f;tauto.
    - intros (n&In);revert In;induction n.
      + discriminate.
      + intros (u&v&E&I1&I2).
        destruct u as [|b u].
        * simpl in E;subst;apply IHn,I2.
        * simpl in E;inversion E;subst;clear IHn E.
          apply IHe in I1 as (f&If&Iu).
          exists (fÂ·eâ‹†);split.
          -- apply in_map_iff;exists f;tauto.
          -- exists u,v;repeat split.
             ++ assumption.
             ++ exists n;tauto.
    - intros (f&If&Iw).
      apply in_map_iff in If as (f'&<-&If').
      destruct Iw as (u&v&->&I1&n&I2).
      exists (S n),(a::u),v;repeat split.
      + apply IHe;exists f';tauto.
      + assumption.
    - intros E;inversion E;subst.
      simpl_beq;exists e_un;split.
      + now left.
      + reflexivity.
    - destruct_eqX a x;subst;intros (f&If&Iw).
      + destruct If as [<-|F];[|exfalso;apply F].
        rewrite Iw;reflexivity.
      + exfalso;apply If.
  Qed.

  Remark In_Î´A_stateSpace_incl : (forall e f a, f âˆˆ Î´A a e -> stateSpace f âŠ† stateSpace e).
  Proof.
    intros;apply stateSpace_trans.
    apply Î´A_stateSpace in H;assumption.
  Qed.

 Lemma test0_Î´A e x : test0 e = true -> forall f, f âˆˆ Î´A x e -> test0 f = true.
  Proof.
    induction e;simpl;try tauto||discriminate.
    - rewrite andb_true_iff;intros (h1&h2) f;simpl_In;intros [I|I];
        [apply IHe1,I|apply IHe2,I];assumption.
    - rewrite orb_true_iff;intros [h|h] f;simpl_In;
        (intros [I|I];[apply in_map_iff in I as (g&<-&Ig)|revert I;unfold_eqX;simpl;[|tauto]]).
      + simpl;apply orb_true_iff;left;apply IHe1;assumption.
      + exfalso.
        apply test0_spec,soundness in h;simpl in h.
        exfalso;cut (ğŸ¬ (@nil X));[tauto|].
        apply h,Ïµ_spec,E.
      + simpl;apply orb_true_iff;right;assumption.
      + apply IHe2,h.
  Qed.

  Lemma stateSpace_Var e f : e âˆˆ stateSpace f -> Var e âŠ† Var f.
  Proof.
    revert e;induction f;intros e;simpl.
    - intros [<-|F];[reflexivity|tauto].
    - intros [<-|F];[reflexivity|tauto].
    - simpl_In;intros [<-|[I|I]];
        [simpl;reflexivity
        |rewrite IHf1 by assumption;intro;simpl_In;tauto
        |rewrite IHf2 by assumption;intro;simpl_In;tauto].
    - simpl_In;intros [<-|[I|I]];
        [simpl;reflexivity
        |
        |destruct (test0 f1);simpl in I;[tauto|];rewrite IHf2 by assumption;intro;simpl_In;tauto].
      apply in_map_iff in I as (g&<-&Ig);simpl.
      rewrite IHf1 by assumption;reflexivity.
    - simpl_In;intros [<-|I];
        [simpl;reflexivity|].
      apply in_map_iff in I as (g&<-&Ig);simpl.
      rewrite IHf by assumption;intro;simpl_In;tauto.
    - intros [<-|[<-|F]];[reflexivity|apply incl_nil|tauto].
  Qed.
End Antimirov.
(* begin hide *)
Section simulation_expr.
  Context {X : Set}{dec_X : decidable_set X}.
  Notation E := (@regexp X).

  CoInductive similar (e f : E) : Prop :=
  | simulation_step : Ïµ e <=KA Ïµ f -> (forall a, similar (Î´ a e) (Î´ a f)) -> similar e f.

  Lemma simulation_language (e f : E) :
    âŸ¦eâŸ§ â‰² âŸ¦fâŸ§ <-> similar e f.
  Proof.
    split.
    - revert e f;cofix hE.
      intros e f hL;apply simulation_step.
      + destruct (Ïµ_zero_or_un e) as [e1|e0].
        * rewrite e1.
          apply Ïµ_spec,hL,Ïµ_spec in e1 as ->;reflexivity.
        * rewrite e0;unfold ax_inf;eauto.
      + intros a;apply hE.
        intros u;repeat rewrite <- Î´_lang;apply hL.
    - intros hE u;revert e f hE.
      induction u;intros e f hE;inversion hE as [h1 hS]. 
      + rewrite (Ïµ_inf_e f) in h1.
        apply ax_inf_lang_incl in h1.
        intros e1;apply Ïµ_spec in e1.
        apply h1;rewrite e1;reflexivity.
      + repeat rewrite Î´_lang.
        apply IHu,hS.
  Qed.

  Lemma similar_join e f g : similar (e âˆª f) g -> similar e g /\ similar f g.
  Proof.
    repeat rewrite <-simulation_language.
    intros L;split;rewrite <- L;simpl;[apply inf_cup_left|apply inf_cup_right].
  Qed.
     
End simulation_expr.
(* end hide *)