(** * RIS.words : words, binding monoid and alpha-equivalence. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Require Export tools atoms.

Section s.
  (** * Preliminary definitions *)
  (** ** Parameters *)

  Class Alphabet {a : Set} (A : Atom a) (X : Set) :=
    {
      dec_X :> decidable_set X;
      support_X :> Support A X;
      action_X :> Action A X;
      nom_X :> Nominal A X
    }.

  (** Type of atoms *)
  Context {atom : Set}{ğ€ : Atom atom}.

  (** We take an alphabet [Nom].*)
  Context {X : Set} {ğ— : Alphabet ğ€ X}.

  (** ** Letters *)
  (** Letters are generated by the grammar [open a | close a | var x] where [a] ranges over [atom] and [x] ranges over [X]. *)
  Inductive letter {ğ€ : Atom atom} {Nom : Alphabet ğ€ X}:=
  | open : atom -> letter
  | close : atom -> letter
  | var : X -> letter.
  Notation " âŸ¨ a " := (open a) (at level 0).
  Notation " a âŸ© " := (close a) (at level 0).

  (* begin hide *)
  Ltac simpl_words :=
    try discriminate;
    match goal with
    | [h: [] = _ ++ _ :: _ |- _ ] => apply app_cons_not_nil in h;tauto
    | [h: _ ++ _ :: _ = [] |- _ ] => symmetry in h;apply app_cons_not_nil in h;tauto
    | [h: _ ++[close _] = _ ++[close _] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      inversion h';subst;clear h'
    | [h: _ ++[open _] = _ ++[open _] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      inversion h';subst;clear h'
    | [h: _ ++[var _] = _ ++[var _] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      inversion h';subst;clear h'
    | [h: _ ++ [_] = _ ++ [_] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      try discriminate
    end.
  (* end hide *)

  (** The type [letter] is decidable. *)
  Definition eq_letter l1 l2 :=
    match (l1,l2) with
    | (âŸ¨a, âŸ¨b) | (aâŸ©,bâŸ©) => a=?= b
    | (var x,var y) => x =?= y
    | _ => false 
    end.

  Lemma eq_letter_correct : forall x y : letter, reflect (x = y) (eq_letter x y).
  Proof.
    intros [] [];apply iff_reflect;unfold eq_letter;try rewrite eqX_correct;
      split;try discriminate||(intros ->)||(intro h;inversion h);reflexivity.
  Qed.
  
  Global Instance dec_letter : decidable_set letter :=
    Build_decidable_set eq_letter_correct.

  (** We canonically get a nominal structure over letters from the nominal structures of [Atom] and [Nom]. *)
  Definition supp_letter (l : letter) : list atom :=
    match l with
    | âŸ¨a | aâŸ© => âŒŠaâŒ‹
    | var x => âŒŠxâŒ‹
    end.

  Global Instance support_letter : Support ğ€ letter := supp_letter.

  Definition letter_map Ï€ l :=
    match l with
    | open b => open (Ï€âˆ™b)
    | close b => close (Ï€âˆ™b)
    | var x => var (Ï€âˆ™x)
    end.

  Global Instance action_letter : Action ğ€ letter := letter_map.

  Global Instance group_action_letter : Nominal ğ€ letter.
  Proof.
    split.
    - intros [a|a|x] p;unfold support,support_letter;simpl;intro E;
        unfold act,action_letter;simpl;f_equal;apply action_invariant;auto.
    - intros [a|a|x] p;unfold support,support_letter;simpl;apply support_action.
    - intros [a|a|x] p q;unfold act,action_letter;simpl;f_equal;apply action_compose.
  Qed.    

  (** A word is a list of letters. It is therefore equipped with a nominal structure, following [Nominal_list]. *)
  Definition word {ğ€ X} := list (@letter ğ€ X).

  (** ** Binding monoid *)
  (** The elements of the binding monoid are triples [(m,n,p)], where [m] and [p] are natural numbers and [p] is a boolean. *)
  Definition ğ–¡ := (nat * bool* nat)%type.
  (** The product [(m,n,p)â‹…(m',n',p')] is defined as follows:
    - if [p < m'] then [(m+m'-p,n',p')];
    - if [m' < p] then [(m,n,p'+p-m')];
    - if [p = m'] then [(m,n||n',p')].
   *)
  Definition prod_binding (a b:ğ–¡) : ğ–¡ :=
    match (a,b) with
    | ((m,n,p),(m',n',p')) =>
      if Nat.ltb p m'
      then (m+m'-p,n',p')
      else
        if Nat.ltb m' p
        then (m,n,p'+p-m')
        else (m,n||n',p')
    end.
  Infix " â‹… " := prod_binding (at level 50).

  (** The unit of this product is the element [(0,false,0)]. *)
  Definition Îµ := (0,false,0).
  Hint Transparent Îµ.
  Lemma prod_unit_r a : a â‹… Îµ = a.
  Proof.
    destruct a as ((m,n),p);unfold prod_binding;simpl.
    destruct_ltb p 0;[|lia];simpl_nat.
    destruct_ltb 0 p;auto.
    repeat f_equal.
    - auto with bool.
    - lia.
  Qed.
  Lemma prod_unit_l a : Îµ â‹… a = a.
  Proof.
    destruct a as ((m,n),p);unfold prod_binding;simpl.
    destruct_ltb m 0;[|lia].
    destruct_ltb 0 m;simpl_nat;auto.
    repeat f_equal.
    lia.
  Qed.

  (** The product in [ğ–¡] is associative. *)
  Lemma prod_assoc u v w : u â‹… (vâ‹…w) = (uâ‹…v)â‹… w.
  Proof.
    destruct u as ((m1,n1),p1);
      destruct v as ((m2,n2),p2);
      destruct w as ((m3,n3),p3);
      unfold prod_binding.
    destruct_ltb p2 m3;[destruct_ltb m3 p2;[replace p2 with m3 in * by lia|]|];
      (destruct_ltb p1 m2;[destruct_ltb m2 p1;[replace p1 with m2 in * by lia|]|]).
    + simpl_nat;rewrite PeanoNat.Nat.ltb_irrefl.
      f_equal;f_equal.
      destruct n1;destruct n2;destruct n3;destruct (Nat.ltb 0 m2);destruct (Nat.ltb 0 m3);reflexivity.
    + destruct_ltb (m3 + p1 - m2) m3;[|lia].
      destruct_ltb m3 (m3 + p1 - m2);[lia|].
      f_equal;lia.
    + simpl_nat;rewrite PeanoNat.Nat.ltb_irrefl;repeat (f_equal;auto with bool).
    + destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
    + destruct_ltb (p2 + p1 - m2) m3;[|lia].
      destruct_ltb m3 (p2 + p1 - m2);[lia|].
      f_equal;lia.
    + destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
    + destruct_ltb (m2 + m3 - p2) m2;[|lia].
      destruct_ltb m2 (m2 + m3 - p2);[lia|].
      destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
      f_equal;f_equal;lia.
    + destruct_ltb (p2 + p1 - m2) m3;destruct_ltb m3 (p2 + p1 - m2);destruct_ltb (m2 + m3 - p2) p1;
        destruct_ltb p1 (m2 + m3 - p2);try lia;(f_equal;lia||f_equal);try lia.
    + destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
      destruct_ltb (m2 + m3 - p2) p1;destruct_ltb p1 (m2 + m3 - p2);try lia;auto.
      (f_equal;lia||f_equal);lia.
  Qed.

  (** We will need sometimes to consider the first or last projection of elements from the binding monoid. *)
  Definition c_binding : ğ–¡ -> nat := snd.
  Definition d_binding (x : ğ–¡) : nat := fst(fst x).

  Lemma c_binding_prod x y :
    c_binding (xâ‹…y) = c_binding y + (c_binding x - d_binding y).
  Proof.
    destruct x as ((m,n),p);destruct y as ((m',n'),p').
    unfold prod_binding,d_binding;simpl.
    destruct_ltb p m';simpl;try tauto||lia.
    destruct_ltb m' p;simpl;tauto||lia.
  Qed.

  Lemma d_binding_prod x y :
    d_binding (xâ‹…y) = d_binding x + (d_binding y - c_binding x).
  Proof.
    destruct x as ((m,n),p);destruct y as ((m',n'),p').
    unfold prod_binding,d_binding;simpl.
    destruct_ltb p m';simpl;try tauto||lia.
    destruct_ltb m' p;simpl;tauto||lia.
  Qed.

  (* begin hide *)
  Lemma d_binding_simpl x y z : d_binding ((x,y),z) = x.
  Proof. reflexivity. Qed.
  (* end hide *)

    (** The size of an element [(n,m,p)] is the sum [n+m+p], where the
boolean [true] is identified with [1] and [false] with [0]. *)
  Definition size (x : ğ–¡) :=
    d_binding x + c_binding x.

  Lemma size_prod_bound_sup (a b : ğ–¡) : size (aâ‹…b) <= size a + size b.
  Proof.
    destruct a as ((n,?),p);destruct b as ((n',?),p');unfold prod_binding;
      (destruct_ltb p n';[destruct_ltb n' p|]);unfold size, d_binding;simpl;lia.
  Qed.
  Lemma size_prod_bound_inf_left (a b : ğ–¡) : size a <= size (aâ‹…b) + size b.
  Proof.
    destruct a as ((n,?),p);destruct b as ((n',?),p');unfold prod_binding;
      (destruct_ltb p n';[destruct_ltb n' p|]);unfold size, d_binding;simpl;lia.
  Qed.
  Lemma size_prod_bound_inf_right (a b : ğ–¡) : size b <= size (aâ‹…b) + size a.
  Proof.
    destruct a as ((n,?),p);destruct b as ((n',?),p');unfold prod_binding;
      (destruct_ltb p n';[destruct_ltb n' p|]);unfold size, d_binding;simpl;lia.
  Qed.

  (** ** Binding power *)
  (** The binding power of a letter [l] relative to a name [a], written [ğ—³ a l], is an element of the binding monoid defined as follows: *)
  Definition ğ—³ a l : ğ–¡ :=
    match l with
    | open b => if a =?= b then (0,false,1) else Îµ
    | close b => if a =?= b then (1,false,0) else Îµ
    | var x => (0,inb a âŒŠxâŒ‹,0)
    end.

  (** The binding power of a word [w] relative to a name [a], written [ğ—™ a w], is obtained by extending [ğ—³ a] as a monoid homomorphism from [word] to [ğ–¡]. *)
  Definition ğ—™ a (w : word) := fold_right prod_binding Îµ (map (ğ—³ a) w).

  (** The following trivial simplification lemmas hold. *)
  Lemma ğ—™_singl a x : ğ—™ a [x] = ğ—³ a x.
  Proof. unfold ğ—™;simpl;apply prod_unit_r. Qed.
  Lemma ğ—™_cons a l u : ğ—™ a (l::u) = ğ—³ a l â‹… ğ—™ a u.
  Proof. unfold ğ—™;simpl;auto. Qed.
  Lemma ğ—™_app a u v : ğ—™ a (u++v) = ğ—™ a u â‹… ğ—™ a v.
  Proof.
    unfold ğ—™;simpl;auto.
    rewrite map_app,fold_right_app.
    generalize dependent (fold_right prod_binding (0, false, 0) (map (ğ—³ a) v)).
    induction u;intros;simpl;auto.
    - rewrite prod_unit_l;auto.
    - rewrite IHu,prod_assoc;auto.
  Qed.
  Lemma ğ—™_add a u l : ğ—™ a (u++[l]) = ğ—™ a u â‹… ğ—³ a l.
  Proof.
    rewrite ğ—™_app;simpl;unfold ğ—™;simpl.
    rewrite prod_unit_r;auto.
  Qed.
  Lemma ğ—³_perm Ï€ a l : ğ—³ a (Ï€ âˆ™ l) = ğ—³ (Ï€âˆ— âˆ™ a) l.
  Proof.
    destruct l;simpl.
    - destruct_eqX a (Ï€âˆ™a0).
      + rewrite inverse_comp_l;simpl_beq;auto.
      + destruct_eqX (Ï€âˆ—âˆ™a) a0;auto.
        exfalso;apply N;rewrite <- E;auto.
        rewrite act_p_pinv;reflexivity.
    - destruct_eqX a (Ï€âˆ™a0).
      + rewrite inverse_comp_l;simpl_beq;auto.
      + destruct_eqX (Ï€âˆ—âˆ™a) a0;auto.
        exfalso;apply N;rewrite <- E;auto.
        rewrite act_p_pinv;reflexivity.
    - case_in a (âŒŠÏ€ âˆ™ x âŒ‹);case_in ((Ï€ âˆ—) âˆ™ a) âŒŠ x âŒ‹;reflexivity||exfalso.
      + apply I0,In_act_lists,support_action,I.
      + apply I,support_action,In_act_lists,I0.
  Qed.
  Lemma ğ—™_perm Ï€ a u : ğ—™ a (Ï€âˆ™u) = ğ—™ (Ï€âˆ— âˆ™ a) u.
  Proof.
    induction u.
    - simpl;unfold ğ—™;simpl;auto.
    - simpl;repeat (rewrite ğ—™_cons||setoid_rewrite act_lists_cons).
      rewrite ğ—³_perm. setoid_rewrite IHu;reflexivity.
  Qed.
  (* begin hide *)
  Ltac simpl_binding :=
    repeat rewrite ğ—™_perm
    || rewrite ğ—³_perm
    || rewrite ğ—™_singl
    || rewrite ğ—™_cons
    || rewrite ğ—™_add
    || rewrite ğ—™_app
    || rewrite c_binding_prod
    || rewrite d_binding_prod
    || rewrite d_binding_simpl
    || simpl_beq
    || simpl.
  Tactic Notation "simpl_binding" "in" hyp(h) :=
    repeat (rewrite ğ—™_perm in h)
    || (rewrite ğ—³_perm in h)
    || (rewrite ğ—™_singl in h)
    || (rewrite ğ—™_cons in h)
    || (rewrite ğ—™_add in h)
    || (rewrite ğ—™_app in h)
    || (rewrite c_binding_prod in h)
    || (rewrite d_binding_prod in h)
    || (rewrite d_binding_simpl in h)
    || simpl_beq
    || (simpl in h).
  Tactic Notation "simpl_binding" "in" "*" :=
    repeat (rewrite ğ—™_perm in * )
    || (rewrite ğ—³_perm in * )
    || (rewrite ğ—™_singl in * )
    || (rewrite ğ—™_cons in * )
    || (rewrite ğ—™_add in * )
    || (rewrite ğ—™_app in * )
    || (rewrite c_binding_prod in * )
    || (rewrite d_binding_prod in * )
    || (rewrite d_binding_simpl in * )
    || simpl_beq
    || (simpl in * ).
  (* end hide *)

  (** ** Balance properties *)

  (** [a] is open-balanced in [w], written [a â–· w], if the last component of [ğ—™ a w] is [0]. *)
  Definition open_balanced a w := c_binding (ğ—™ a w) = 0.
  Infix " â–· " := open_balanced (at level 20).

  (** [a] is close-balanced in [w], written [a â— w], if the first component of [ğ—™ a w] is [0]. *)
  Definition close_balanced a w := d_binding (ğ—™ a w) = 0.
  Infix " â— " := close_balanced (at level 20).

  (** [a] is balanced in [w], written [a â‹„ w], if it is both open- and close-balanced. *)
  Definition balanced a w := c_binding (ğ—™ a w) = 0 /\ d_binding (ğ—™ a w) = 0.
  Infix " â‹„ " := balanced (at level 20).

  (**  [a] is Î±-fresh for [w], written [a #Î± w], if [ğ—™ a w=Îµ]. *)
  Definition fresh__Î± a w := ğ—™ a w = (0,false,0).
  Infix " #Î± " := fresh__Î± (at level 30).

  (** The predicate [a â–·] is preserved by taking suffixes. *)
  Lemma open_balanced_suffix a u v : a â–· (u++v) -> a â–· v.
  Proof. unfold open_balanced;rewrite ğ—™_app,c_binding_prod;lia. Qed.
  
  (** The predicate [a â–·] is preserved by taking prefixes. *)
  Lemma close_balanced_prefix a u v : a â— (u++v) -> a â— u.
  Proof. unfold close_balanced;rewrite ğ—™_app,d_binding_prod;lia. Qed.

  (** The balance properties commute with the action of permutations. *)
  Lemma open_balanced_perm Ï€ a u : a â–· (Ï€âˆ™u) <-> (Ï€âˆ—âˆ™a) â–· u.
  Proof. unfold open_balanced;simpl_binding;reflexivity. Qed.
  Lemma close_balanced_perm Ï€ a u : a â— (Ï€âˆ™u) <-> (Ï€âˆ—âˆ™a) â— u.
  Proof. unfold close_balanced;rewrite ğ—™_perm;reflexivity. Qed.
  Lemma balanced_perm Ï€ a u : a â‹„ (Ï€âˆ™u) <-> (Ï€âˆ—âˆ™a) â‹„ u.
  Proof. unfold balanced;rewrite ğ—™_perm;reflexivity. Qed.
  Lemma Î±fresh_perm Ï€ a u : a #Î± (Ï€âˆ™u) <-> (Ï€âˆ—âˆ™a)#Î± u.
  Proof. unfold fresh__Î±;rewrite ğ—™_perm;tauto. Qed.

  (** For letters, freshness and Î±-freshness are equivalent. *)
  Lemma Î±fresh_letter a l : a # l <-> ğ—³ a l = Îµ.
  Proof.
    destruct l;simpl;auto.
    + destruct_eqX a a0;firstorder try discriminate.
      intros [->|F];tauto.
    + destruct_eqX a a0;firstorder try discriminate.
      intros [->|F];tauto.
    + replace âŒŠvar xâŒ‹ with âŒŠxâŒ‹ by reflexivity.
      case_in a âŒŠxâŒ‹;split;tauto||discriminate.
  Qed.

  (** If [a] is fresh for [u], then it is Î±-fresh. Note however that the converse is not true: [a] is Î±-fresh for [[âŸ¨a;aâŸ©]], and yet [aâˆˆâŒŠ[âŸ¨a;aâŸ©]âŒ‹=[a]]. *)
  Lemma Î±fresh_support a u : a # u -> a #Î± u.
  Proof.
    unfold fresh__Î± in *;induction u as [|l u];simpl;auto.
    rewrite ğ—™_cons.
    intro h;rewrite IHu,prod_unit_r.
    - apply Î±fresh_letter.
      intro I;apply h,In_support_list.
      exists l;simpl;auto.
    - intro I;apply h,In_support_list.
      apply In_support_list in I as (l'&I'&I).
      exists l';simpl;auto.
  Qed.

  Lemma open_balanced_no_open u a : ~ open a âˆˆ u -> a â–· u.
  Proof.
    unfold open_balanced;intros I1;induction u;simpl.
    - reflexivity.
    - simpl in *;simpl_binding.
      rewrite IHu by tauto.
      destruct a0;simpl;unfold_eqX;tauto.
  Qed.

  Lemma close_balanced_no_close u a : ~ close a âˆˆ u -> a â— u.
  Proof.
    unfold close_balanced;intros I1;induction u;simpl.
    - reflexivity.
    - simpl in *;simpl_binding.
      rewrite IHu by tauto.
      destruct a0;simpl;unfold_eqX;tauto.
  Qed.
  
  Lemma balanced_open_close u a : ~ open a âˆˆ u -> ~ close a âˆˆ u -> a â‹„ u.
  Proof.
    intros I1 I2;split;[apply open_balanced_no_open|apply close_balanced_no_close];assumption.
  Qed.
  
  (** ** Decomposition properties *)
  (** If [a] is not open-balanced in [u], then there is an unmatched [âŸ¨a] in [u], and therefore a last unmatched [âŸ¨a]. This means that [u] may be factorised as [u1++âŸ¨a::u2], with [a] being balanced in [u2]. *)
  Lemma Î±fresh_close_split u a : ~ a â–· u -> exists u1 u2, u = u1 ++ open a :: u2 /\ a â‹„ u2.
  Proof.
    remember â¢uâ¥ as n.
    assert (L:â¢uâ¥ <= n) by (rewrite Heqn;reflexivity).
    clear Heqn;revert u L;induction n;intros u.
    - destruct u;simpl;try lia.
      unfold open_balanced,ğ—™,prod_binding at 1;simpl;tauto.
    - destruct_eqX u (@nil letter).
      + unfold open_balanced,ğ—™,prod_binding at 1;simpl;tauto. 
      + apply not_nil_add in N as (w&[b|b|x]&->).
        * unfold open_balanced in *;rewrite app_length;simpl.
          intro L';assert (L:length  w <= n) by lia;clear L'.
          destruct_eqX a b;[symmetry in E;subst|];simpl.
          -- intros _;exists w,[];split;auto.
             unfold balanced;simpl;tauto.
          -- intros F;destruct (IHn _ L) as (u1&u2&->&B).
             ++ revert F;simpl_binding;lia.
             ++ exists u1,(u2++[open b]).
                rewrite app_ass;simpl;split;auto;destruct B as (B1&B2).
                unfold balanced,close_balanced,open_balanced in *.
                revert F;simpl_binding;rewrite B1,B2;simpl;auto.
        * unfold open_balanced in *.
          rewrite app_length;simpl;intro L';assert (Lw:length  w <= n) by lia;clear L'.
          simpl_binding;destruct_eqX b a;subst;simpl_binding.
          -- intros E; destruct (IHn _ Lw) as (u0&u3&->&B3);auto.
             ++ intro Ew;apply E;lia.
             ++ revert E;simpl_binding;destruct B3 as (C3&D3);rewrite C3,D3;simpl.
                assert (Lu0:â¢u0â¥ <= n) by (rewrite app_length in Lw;simpl in Lw;lia);clear Lw.
                intro;destruct (IHn _ Lu0) as (u1&u2&->&B2);[lia|].
                exists u1,(u2++open a::u3++[close a]).
                repeat rewrite app_ass;simpl;split;auto.
                destruct B2 as (B1&B2);unfold balanced;simpl_binding;rewrite B1,B2,C3,D3;auto.
          -- intros E; destruct (IHn _ Lw) as (u1&u2&->&C3&D3);[lia|].
             exists u1,(u2++[close b]);rewrite app_ass;simpl;split;auto.
             unfold balanced;simpl_binding;rewrite C3,D3;auto. 
        * intros L B;destruct (IHn w) as (u1&u2&->&B').
          ++ rewrite app_length in L;simpl in L;lia.
          ++ revert B;unfold open_balanced;simpl_binding;lia.
          ++ exists u1,(u2++[var x]);rewrite app_ass;simpl;split;auto.
             revert B';unfold balanced;simpl_binding;lia.
  Qed.

  (** Similarly, for closing brackets. *)
  Lemma Î±fresh_open_split u a : ~ a â— u -> exists u1 u2, u = u1 ++ close a :: u2 /\ a â‹„ u1.
  Proof.
    unfold close_balanced;induction u using len_induction;simpl.
    - unfold ğ—™,prod_binding at 1;simpl;tauto.
    - simpl_binding.
      destruct a0 as [b|b|x];simpl;unfold_eqX;simpl;subst.
      + intros L.
        destruct (H l) as (u1&u2&->&B).
        * reflexivity.
        * lia.
        * destruct (H u2) as (v1&v2&->&B').
          -- solve_length.
          -- revert L;simpl_binding;destruct B as (->&->);lia.
          -- exists (open b::u1++close b::v1),v2;simpl;split.
             ++ repeat rewrite app_ass;reflexivity.
             ++ unfold balanced;simpl_binding;destruct B as (->&->),B' as (->&->);simpl;tauto.
      + simpl_nat;intro D;apply H in D as (u1&u2&->&B);[|reflexivity].
        exists (open b::u1),u2;unfold balanced;simpl_binding;destruct B as (->&->);tauto.
      + intros _;exists [],l;simpl;repeat split.
      + simpl_nat;intro D;apply H in D as (u1&u2&->&B);[|reflexivity].
        exists (close b::u1),u2;unfold balanced;simpl_binding;destruct B as (->&->);tauto.
      + simpl_nat;intro D;apply H in D as (u1&u2&->&B);[|reflexivity].
        exists (var x::u1),u2;unfold balanced;simpl_binding;destruct B as (->&->);tauto.
  Qed.
  
  (** This decomposition is unique.*)
  Lemma Î±fresh_close_split_unique u1 u2 v1 v2 a :
    u1 ++ open a :: u2 = v1 ++ open a :: v2 -> a â‹„ u2 -> a â‹„ v2 -> u1 = v1 /\ u2 = v2.
  Proof.
    intros E B1 B2;levi E.
    - inversion E1;auto.
    - exfalso;inversion E1;subst;clear E E1.
      destruct B2 as (B2&_);apply open_balanced_suffix in B2.
      revert B2;unfold open_balanced;simpl_binding;destruct B1 as (->&->);lia. 
    - exfalso;inversion E1;subst;clear E E1.
      destruct B1 as (B1&_);apply open_balanced_suffix in B1.
      revert B1;unfold open_balanced;simpl_binding;destruct B2 as (->&->);lia.
  Qed.
  
  (** * Alpha-equivalence *)
  (** We write [â‰¡] for the relation defined as follows: 
    - [â‰¡] is transitive, and [[]â‰¡[]];
    - if [uâ‰¡v], then [x::uâ‰¡x::v] and [u++[x]â‰¡v++[x]];
    - if [b] is Î±-fresh in [u] and [a] is balanced in [u], then [âŸ¨a::u++[aâŸ©]] is equivalent to [âŸ¨b::([(a,b)]âˆ™u)++[bâŸ©]].
   *)
  Inductive Î±equiv : Equiv word :=
  | Î±t u v w : u â‰¡ v -> v â‰¡ w -> u â‰¡ w
  | Î±Îµ : [] â‰¡ []
  | Î±r u v l : u â‰¡ v -> u++[l] â‰¡ v++[l]
  | Î±l u v l : u â‰¡ v -> l::u â‰¡ l::v
  | Î±Î± a b u : b #Î± u -> a â‹„ u -> âŸ¨a::u++[aâŸ©] â‰¡ âŸ¨b::([(a,b)]âˆ™u)++[bâŸ©].
  Hint Constructors Î±equiv.
  (* begin hide *)
  Global Instance wequiv : Equiv word := Î±equiv.
  (* end hide *)
  
  (** This is an equivalence relation. *)
  Global Instance Î±equiv_equivalence : Equivalence equiv.
  Proof.
    split.
    - intro w;induction w using rev_induction;auto.
    - intros u v E;induction E;eauto.
      assert (E: u = [(b,a)]âˆ™([(a,b)]âˆ™u)).
      + rewrite action_compose;symmetry;apply action_invariant,map_eq_id.
        intros x I;repeat setoid_rewrite act_cons;rewrite act_nil;simpl.
        destruct_eqX x a;auto.
        destruct_eqX x b;try simpl_beq;auto.
      + rewrite E at 2;apply Î±Î±.
        * apply Î±fresh_perm;simpl.
          repeat setoid_rewrite act_cons;rewrite act_nil;simpl;simpl_beq;auto.
        * apply balanced_perm;simpl;repeat setoid_rewrite act_cons;rewrite act_nil;simpl;
            simpl_beq;auto;destruct_eqX b a;auto.
    - eauto.
  Qed.

  (** This relation is a congruence. *)
  Lemma Î±equiv_app_left u v w : u â‰¡ v -> w++uâ‰¡w++v.
  Proof. intro E;induction w;simpl;auto. Qed.
  Lemma Î±equiv_app_right (u v w : word) : u â‰¡ v -> u++wâ‰¡v++w.
  Proof. 
    intro E;revert w;induction w using rev_induction;simpl;auto.
    + repeat rewrite app_nil_r;auto.
    + repeat rewrite <- app_ass; apply Î±r;auto.
  Qed.

  Global Instance Î±equiv_app :
    Proper (equiv ==> equiv ==> equiv) (@app letter).
  Proof.
    intros u1 v1 E1 u2 v2 E2.
    transitivity (u1++v2).
    - apply Î±equiv_app_left;auto.
    - apply Î±equiv_app_right;auto.
  Qed.

  (** Equivalent words have the same length. *)
  Lemma Î±equiv_length u v : u â‰¡ v -> â¢uâ¥ = â¢vâ¥.
  Proof.
    intro E;induction E;simpl;auto.
    - lia.
    - repeat rewrite app_length;lia.
    - repeat rewrite app_length. setoid_rewrite act_lists_length.
      simpl;lia.
  Qed.

  (** Equivalent words have the same binding power. *)
  Lemma Î±equiv_binding u v : u â‰¡ v -> forall a, ğ—™ a u = ğ—™ a v.
  Proof.
    intro E;induction E;intro x;simpl;auto.
    - rewrite IHE,IHE0;reflexivity.
    - repeat rewrite ğ—™_add;rewrite IHE;auto.
    - repeat rewrite ğ—™_cons;rewrite IHE;auto.
    - repeat rewrite ğ—™_cons,ğ—™_add.
      rewrite ğ—™_perm;simpl.
      rewrite act_cons,act_nil.
      destruct_eqX b a;subst;destruct_eqX x a;repeat simpl_beq;auto.
      + unfold balanced,fresh__Î± in *;destruct H0 as (C&D).
        rewrite H;simpl;destruct (ğ—™ a u) as ((m,?),n);unfold d_binding in D;simpl in *.
        rewrite C,D;reflexivity.
      + destruct_eqX x b;auto.
        unfold balanced,fresh__Î± in *;destruct H0 as (C&D).
        rewrite H;simpl;destruct (ğ—™ a u) as ((m,?),n);unfold d_binding in D;simpl in *.
        rewrite C,D;reflexivity.
  Qed.

  (** This relation commutes with the action of permutations. *)
  Lemma Î±equiv_perm u v Ï€ : u â‰¡ v -> Ï€ âˆ™ u â‰¡ Ï€ âˆ™ v.
  Proof.
    intro E;revert Ï€;induction E;intro Ï€;simpl;eauto.
    - setoid_rewrite act_lists_app;rewrite IHE;reflexivity.
    - setoid_rewrite act_lists_cons;apply Î±l,IHE.
    - setoid_rewrite act_lists_cons;setoid_rewrite act_lists_app.
      unfold act at 1 3 4 7;simpl.
      unfold act at 3 7;simpl.
      rewrite action_compose.
      replace ((Ï€ ++ [(a, b)]) âˆ™ u) with (([(Ï€ âˆ™ a, Ï€ âˆ™ b)] ++ Ï€) âˆ™ u).
      + rewrite<-action_compose;apply Î±Î±.
        * apply Î±fresh_perm;rewrite inverse_comp_l;auto.
        * apply balanced_perm;rewrite inverse_comp_l;auto.
      + apply equiv_perm_act;auto.
        intro x;simpl;rewrite <- action_compose.
        repeat rewrite act_cons;rewrite act_nil.
        destruct_eqX x a;auto.
        destruct_eqX x b;auto.
        * rewrite <- act_bij with (p:=Ï€) in N.
          apply eqX_false in N;setoid_rewrite N;auto.
        * rewrite <- act_bij with (p:=Ï€) in N.
          rewrite <- act_bij with (p:=Ï€) in N0.
          apply eqX_false in N;setoid_rewrite N;auto.
          apply eqX_false in N0;setoid_rewrite N0;auto.
  Qed.

End s.
Hint Transparent Îµ.

Notation " âŸ¨ a " := (open a) (at level 0).
Notation " a âŸ© " := (close a) (at level 0).
Infix " â‹… " := prod_binding (at level 50).
Infix " #Î± " := fresh__Î± (at level 30).
Infix " â‹„ " := balanced (at level 20).
Infix " â— " := close_balanced (at level 20).
Infix " â–· " := open_balanced (at level 20).

(* begin hide *)
Ltac simpl_words :=
  try discriminate;
  match goal with
  | [h: [] = _ ++ _ :: _ |- _ ] => apply app_cons_not_nil in h;tauto
  | [h: _ ++ _ :: _ = [] |- _ ] => symmetry in h;apply app_cons_not_nil in h;tauto
  | [h: _ ++[close _] = _ ++[close _] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    inversion h';subst;clear h'
  | [h: _ ++[open _] = _ ++[open _] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    inversion h';subst;clear h'
  | [h: _ ++[var _] = _ ++[var _] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    inversion h';subst;clear h'
  | [h: _ ++ [_] = _ ++ [_] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    try discriminate
  end.
Ltac simpl_binding :=
  repeat (simpl;
          rewrite ğ—™_perm
          || rewrite ğ—³_perm
          || rewrite ğ—™_singl
          || rewrite ğ—™_cons
          || rewrite ğ—™_add
          || rewrite ğ—™_app
          || rewrite c_binding_prod
          || rewrite d_binding_prod
          || rewrite d_binding_simpl
          || (replace (d_binding Îµ) with 0 by reflexivity)
          || (replace (c_binding Îµ) with 0 by reflexivity)
          || simpl_beq).
Tactic Notation "simpl_binding" "in" hyp(h) :=
  repeat (rewrite ğ—™_perm in h)
  || (rewrite ğ—³_perm in h)
  || (rewrite ğ—™_singl in h)
  || (rewrite ğ—™_cons in h)
  || (rewrite ğ—™_add in h)
  || (rewrite ğ—™_app in h)
  || (rewrite c_binding_prod in h)
  || (rewrite d_binding_prod in h)
  || (rewrite d_binding_simpl in h)
  || simpl_beq
  || (simpl in h).
Tactic Notation "simpl_binding" "in" "*" :=
  repeat (rewrite ğ—™_perm in * )
  || (rewrite ğ—³_perm in * )
  || (rewrite ğ—™_singl in * )
  || (rewrite ğ—™_cons in * )
  || (rewrite ğ—™_add in * )
  || (rewrite ğ—™_app in * )
  || (rewrite c_binding_prod in * )
  || (rewrite d_binding_prod in * )
  || (rewrite d_binding_simpl in * )
  || simpl_beq
  || (simpl in * ).
Hint Constructors Î±equiv.
(* end hide *)
