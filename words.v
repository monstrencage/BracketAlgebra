(** * RIS.words : words, binding monoid and alpha-equivalence. *)
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Require Export tools atoms.

Section s.
  (** * Preliminary definitions *)
  (** ** Parameters *)

  Class Alphabet {a : Set} (A : Atom a) (X : Set) :=
    {
      dec_X :> decidable_set X;
      support_X :> Support A X;
      action_X :> Action A X;
      nom_X :> Nominal A X
    }.

  (** Type of atoms *)
  Context {atom : Set}{𝐀 : Atom atom}.

  (** We take an alphabet [Nom].*)
  Context {X : Set} {𝐗 : Alphabet 𝐀 X}.

  (** ** Letters *)
  (** Letters are generated by the grammar [open a | close a | var x] where [a] ranges over [atom] and [x] ranges over [X]. *)
  Inductive letter {𝐀 : Atom atom} {Nom : Alphabet 𝐀 X}:=
  | open : atom -> letter
  | close : atom -> letter
  | var : X -> letter.
  Notation " ⟨ a " := (open a) (at level 0).
  Notation " a ⟩ " := (close a) (at level 0).

  (* begin hide *)
  Ltac simpl_words :=
    try discriminate;
    match goal with
    | [h: [] = _ ++ _ :: _ |- _ ] => apply app_cons_not_nil in h;tauto
    | [h: _ ++ _ :: _ = [] |- _ ] => symmetry in h;apply app_cons_not_nil in h;tauto
    | [h: _ ++[close _] = _ ++[close _] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      inversion h';subst;clear h'
    | [h: _ ++[open _] = _ ++[open _] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      inversion h';subst;clear h'
    | [h: _ ++[var _] = _ ++[var _] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      inversion h';subst;clear h'
    | [h: _ ++ [_] = _ ++ [_] |- _ ] =>
      let h' := fresh "h" in
      apply app_inj_tail in h as (h,h');
      try discriminate
    end.
  (* end hide *)

  (** The type [letter] is decidable. *)
  Definition eq_letter l1 l2 :=
    match (l1,l2) with
    | (⟨a, ⟨b) | (a⟩,b⟩) => a=?= b
    | (var x,var y) => x =?= y
    | _ => false 
    end.

  Lemma eq_letter_correct : forall x y : letter, reflect (x = y) (eq_letter x y).
  Proof.
    intros [] [];apply iff_reflect;unfold eq_letter;try rewrite eqX_correct;
      split;try discriminate||(intros ->)||(intro h;inversion h);reflexivity.
  Qed.
  
  Global Instance dec_letter : decidable_set letter :=
    Build_decidable_set eq_letter_correct.

  (** We canonically get a nominal structure over letters from the nominal structures of [Atom] and [Nom]. *)
  Definition supp_letter (l : letter) : list atom :=
    match l with
    | ⟨a | a⟩ => ⌊a⌋
    | var x => ⌊x⌋
    end.

  Global Instance support_letter : Support 𝐀 letter := supp_letter.

  Definition letter_map π l :=
    match l with
    | open b => open (π∙b)
    | close b => close (π∙b)
    | var x => var (π∙x)
    end.

  Global Instance action_letter : Action 𝐀 letter := letter_map.

  Global Instance group_action_letter : Nominal 𝐀 letter.
  Proof.
    split.
    - intros [a|a|x] p;unfold support,support_letter;simpl;intro E;
        unfold act,action_letter;simpl;f_equal;apply action_invariant;auto.
    - intros [a|a|x] p;unfold support,support_letter;simpl;apply support_action.
    - intros [a|a|x] p q;unfold act,action_letter;simpl;f_equal;apply action_compose.
  Qed.    

  (** A word is a list of letters. It is therefore equipped with a nominal structure, following [Nominal_list]. *)
  Definition word {𝐀 X} := list (@letter 𝐀 X).

  (** ** Binding monoid *)
  (** The elements of the binding monoid are triples [(m,n,p)], where [m] and [p] are natural numbers and [p] is a boolean. *)
  Definition 𝖡 := (nat * bool* nat)%type.
  (** The product [(m,n,p)⋅(m',n',p')] is defined as follows:
    - if [p < m'] then [(m+m'-p,n',p')];
    - if [m' < p] then [(m,n,p'+p-m')];
    - if [p = m'] then [(m,n||n',p')].
   *)
  Definition prod_binding (a b:𝖡) : 𝖡 :=
    match (a,b) with
    | ((m,n,p),(m',n',p')) =>
      if Nat.ltb p m'
      then (m+m'-p,n',p')
      else
        if Nat.ltb m' p
        then (m,n,p'+p-m')
        else (m,n||n',p')
    end.
  Infix " ⋅ " := prod_binding (at level 50).

  (** The unit of this product is the element [(0,false,0)]. *)
  Definition ε := (0,false,0).
  Hint Transparent ε.
  Lemma prod_unit_r a : a ⋅ ε = a.
  Proof.
    destruct a as ((m,n),p);unfold prod_binding;simpl.
    destruct_ltb p 0;[|lia];simpl_nat.
    destruct_ltb 0 p;auto.
    repeat f_equal.
    - auto with bool.
    - lia.
  Qed.
  Lemma prod_unit_l a : ε ⋅ a = a.
  Proof.
    destruct a as ((m,n),p);unfold prod_binding;simpl.
    destruct_ltb m 0;[|lia].
    destruct_ltb 0 m;simpl_nat;auto.
    repeat f_equal.
    lia.
  Qed.

  (** The product in [𝖡] is associative. *)
  Lemma prod_assoc u v w : u ⋅ (v⋅w) = (u⋅v)⋅ w.
  Proof.
    destruct u as ((m1,n1),p1);
      destruct v as ((m2,n2),p2);
      destruct w as ((m3,n3),p3);
      unfold prod_binding.
    destruct_ltb p2 m3;[destruct_ltb m3 p2;[replace p2 with m3 in * by lia|]|];
      (destruct_ltb p1 m2;[destruct_ltb m2 p1;[replace p1 with m2 in * by lia|]|]).
    + simpl_nat;rewrite PeanoNat.Nat.ltb_irrefl.
      f_equal;f_equal.
      destruct n1;destruct n2;destruct n3;destruct (Nat.ltb 0 m2);destruct (Nat.ltb 0 m3);reflexivity.
    + destruct_ltb (m3 + p1 - m2) m3;[|lia].
      destruct_ltb m3 (m3 + p1 - m2);[lia|].
      f_equal;lia.
    + simpl_nat;rewrite PeanoNat.Nat.ltb_irrefl;repeat (f_equal;auto with bool).
    + destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
    + destruct_ltb (p2 + p1 - m2) m3;[|lia].
      destruct_ltb m3 (p2 + p1 - m2);[lia|].
      f_equal;lia.
    + destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
    + destruct_ltb (m2 + m3 - p2) m2;[|lia].
      destruct_ltb m2 (m2 + m3 - p2);[lia|].
      destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
      f_equal;f_equal;lia.
    + destruct_ltb (p2 + p1 - m2) m3;destruct_ltb m3 (p2 + p1 - m2);destruct_ltb (m2 + m3 - p2) p1;
        destruct_ltb p1 (m2 + m3 - p2);try lia;(f_equal;lia||f_equal);try lia.
    + destruct_ltb p2 m3;lia||destruct_ltb m3 p2;try lia;auto.
      destruct_ltb (m2 + m3 - p2) p1;destruct_ltb p1 (m2 + m3 - p2);try lia;auto.
      (f_equal;lia||f_equal);lia.
  Qed.

  (** We will need sometimes to consider the first or last projection of elements from the binding monoid. *)
  Definition c_binding : 𝖡 -> nat := snd.
  Definition d_binding (x : 𝖡) : nat := fst(fst x).

  Lemma c_binding_prod x y :
    c_binding (x⋅y) = c_binding y + (c_binding x - d_binding y).
  Proof.
    destruct x as ((m,n),p);destruct y as ((m',n'),p').
    unfold prod_binding,d_binding;simpl.
    destruct_ltb p m';simpl;try tauto||lia.
    destruct_ltb m' p;simpl;tauto||lia.
  Qed.

  Lemma d_binding_prod x y :
    d_binding (x⋅y) = d_binding x + (d_binding y - c_binding x).
  Proof.
    destruct x as ((m,n),p);destruct y as ((m',n'),p').
    unfold prod_binding,d_binding;simpl.
    destruct_ltb p m';simpl;try tauto||lia.
    destruct_ltb m' p;simpl;tauto||lia.
  Qed.

  (* begin hide *)
  Lemma d_binding_simpl x y z : d_binding ((x,y),z) = x.
  Proof. reflexivity. Qed.
  (* end hide *)

    (** The size of an element [(n,m,p)] is the sum [n+m+p], where the
boolean [true] is identified with [1] and [false] with [0]. *)
  Definition size (x : 𝖡) :=
    d_binding x + c_binding x.

  Lemma size_prod_bound_sup (a b : 𝖡) : size (a⋅b) <= size a + size b.
  Proof.
    destruct a as ((n,?),p);destruct b as ((n',?),p');unfold prod_binding;
      (destruct_ltb p n';[destruct_ltb n' p|]);unfold size, d_binding;simpl;lia.
  Qed.
  Lemma size_prod_bound_inf_left (a b : 𝖡) : size a <= size (a⋅b) + size b.
  Proof.
    destruct a as ((n,?),p);destruct b as ((n',?),p');unfold prod_binding;
      (destruct_ltb p n';[destruct_ltb n' p|]);unfold size, d_binding;simpl;lia.
  Qed.
  Lemma size_prod_bound_inf_right (a b : 𝖡) : size b <= size (a⋅b) + size a.
  Proof.
    destruct a as ((n,?),p);destruct b as ((n',?),p');unfold prod_binding;
      (destruct_ltb p n';[destruct_ltb n' p|]);unfold size, d_binding;simpl;lia.
  Qed.

  (** ** Binding power *)
  (** The binding power of a letter [l] relative to a name [a], written [𝗳 a l], is an element of the binding monoid defined as follows: *)
  Definition 𝗳 a l : 𝖡 :=
    match l with
    | open b => if a =?= b then (0,false,1) else ε
    | close b => if a =?= b then (1,false,0) else ε
    | var x => (0,inb a ⌊x⌋,0)
    end.

  (** The binding power of a word [w] relative to a name [a], written [𝗙 a w], is obtained by extending [𝗳 a] as a monoid homomorphism from [word] to [𝖡]. *)
  Definition 𝗙 a (w : word) := fold_right prod_binding ε (map (𝗳 a) w).

  (** The following trivial simplification lemmas hold. *)
  Lemma 𝗙_singl a x : 𝗙 a [x] = 𝗳 a x.
  Proof. unfold 𝗙;simpl;apply prod_unit_r. Qed.
  Lemma 𝗙_cons a l u : 𝗙 a (l::u) = 𝗳 a l ⋅ 𝗙 a u.
  Proof. unfold 𝗙;simpl;auto. Qed.
  Lemma 𝗙_app a u v : 𝗙 a (u++v) = 𝗙 a u ⋅ 𝗙 a v.
  Proof.
    unfold 𝗙;simpl;auto.
    rewrite map_app,fold_right_app.
    generalize dependent (fold_right prod_binding (0, false, 0) (map (𝗳 a) v)).
    induction u;intros;simpl;auto.
    - rewrite prod_unit_l;auto.
    - rewrite IHu,prod_assoc;auto.
  Qed.
  Lemma 𝗙_add a u l : 𝗙 a (u++[l]) = 𝗙 a u ⋅ 𝗳 a l.
  Proof.
    rewrite 𝗙_app;simpl;unfold 𝗙;simpl.
    rewrite prod_unit_r;auto.
  Qed.
  Lemma 𝗳_perm π a l : 𝗳 a (π ∙ l) = 𝗳 (π∗ ∙ a) l.
  Proof.
    destruct l;simpl.
    - destruct_eqX a (π∙a0).
      + rewrite inverse_comp_l;simpl_beq;auto.
      + destruct_eqX (π∗∙a) a0;auto.
        exfalso;apply N;rewrite <- E;auto.
        rewrite act_p_pinv;reflexivity.
    - destruct_eqX a (π∙a0).
      + rewrite inverse_comp_l;simpl_beq;auto.
      + destruct_eqX (π∗∙a) a0;auto.
        exfalso;apply N;rewrite <- E;auto.
        rewrite act_p_pinv;reflexivity.
    - case_in a (⌊π ∙ x ⌋);case_in ((π ∗) ∙ a) ⌊ x ⌋;reflexivity||exfalso.
      + apply I0,In_act_lists,support_action,I.
      + apply I,support_action,In_act_lists,I0.
  Qed.
  Lemma 𝗙_perm π a u : 𝗙 a (π∙u) = 𝗙 (π∗ ∙ a) u.
  Proof.
    induction u.
    - simpl;unfold 𝗙;simpl;auto.
    - simpl;repeat (rewrite 𝗙_cons||setoid_rewrite act_lists_cons).
      rewrite 𝗳_perm. setoid_rewrite IHu;reflexivity.
  Qed.
  (* begin hide *)
  Ltac simpl_binding :=
    repeat rewrite 𝗙_perm
    || rewrite 𝗳_perm
    || rewrite 𝗙_singl
    || rewrite 𝗙_cons
    || rewrite 𝗙_add
    || rewrite 𝗙_app
    || rewrite c_binding_prod
    || rewrite d_binding_prod
    || rewrite d_binding_simpl
    || simpl_beq
    || simpl.
  Tactic Notation "simpl_binding" "in" hyp(h) :=
    repeat (rewrite 𝗙_perm in h)
    || (rewrite 𝗳_perm in h)
    || (rewrite 𝗙_singl in h)
    || (rewrite 𝗙_cons in h)
    || (rewrite 𝗙_add in h)
    || (rewrite 𝗙_app in h)
    || (rewrite c_binding_prod in h)
    || (rewrite d_binding_prod in h)
    || (rewrite d_binding_simpl in h)
    || simpl_beq
    || (simpl in h).
  Tactic Notation "simpl_binding" "in" "*" :=
    repeat (rewrite 𝗙_perm in * )
    || (rewrite 𝗳_perm in * )
    || (rewrite 𝗙_singl in * )
    || (rewrite 𝗙_cons in * )
    || (rewrite 𝗙_add in * )
    || (rewrite 𝗙_app in * )
    || (rewrite c_binding_prod in * )
    || (rewrite d_binding_prod in * )
    || (rewrite d_binding_simpl in * )
    || simpl_beq
    || (simpl in * ).
  (* end hide *)

  (** ** Balance properties *)

  (** [a] is open-balanced in [w], written [a ▷ w], if the last component of [𝗙 a w] is [0]. *)
  Definition open_balanced a w := c_binding (𝗙 a w) = 0.
  Infix " ▷ " := open_balanced (at level 20).

  (** [a] is close-balanced in [w], written [a ◁ w], if the first component of [𝗙 a w] is [0]. *)
  Definition close_balanced a w := d_binding (𝗙 a w) = 0.
  Infix " ◁ " := close_balanced (at level 20).

  (** [a] is balanced in [w], written [a ⋄ w], if it is both open- and close-balanced. *)
  Definition balanced a w := c_binding (𝗙 a w) = 0 /\ d_binding (𝗙 a w) = 0.
  Infix " ⋄ " := balanced (at level 20).

  (**  [a] is α-fresh for [w], written [a #α w], if [𝗙 a w=ε]. *)
  Definition fresh__α a w := 𝗙 a w = (0,false,0).
  Infix " #α " := fresh__α (at level 30).

  (** The predicate [a ▷] is preserved by taking suffixes. *)
  Lemma open_balanced_suffix a u v : a ▷ (u++v) -> a ▷ v.
  Proof. unfold open_balanced;rewrite 𝗙_app,c_binding_prod;lia. Qed.
  
  (** The predicate [a ▷] is preserved by taking prefixes. *)
  Lemma close_balanced_prefix a u v : a ◁ (u++v) -> a ◁ u.
  Proof. unfold close_balanced;rewrite 𝗙_app,d_binding_prod;lia. Qed.

  (** The balance properties commute with the action of permutations. *)
  Lemma open_balanced_perm π a u : a ▷ (π∙u) <-> (π∗∙a) ▷ u.
  Proof. unfold open_balanced;simpl_binding;reflexivity. Qed.
  Lemma close_balanced_perm π a u : a ◁ (π∙u) <-> (π∗∙a) ◁ u.
  Proof. unfold close_balanced;rewrite 𝗙_perm;reflexivity. Qed.
  Lemma balanced_perm π a u : a ⋄ (π∙u) <-> (π∗∙a) ⋄ u.
  Proof. unfold balanced;rewrite 𝗙_perm;reflexivity. Qed.
  Lemma αfresh_perm π a u : a #α (π∙u) <-> (π∗∙a)#α u.
  Proof. unfold fresh__α;rewrite 𝗙_perm;tauto. Qed.

  (** For letters, freshness and α-freshness are equivalent. *)
  Lemma αfresh_letter a l : a # l <-> 𝗳 a l = ε.
  Proof.
    destruct l;simpl;auto.
    + destruct_eqX a a0;firstorder try discriminate.
      intros [->|F];tauto.
    + destruct_eqX a a0;firstorder try discriminate.
      intros [->|F];tauto.
    + replace ⌊var x⌋ with ⌊x⌋ by reflexivity.
      case_in a ⌊x⌋;split;tauto||discriminate.
  Qed.

  (** If [a] is fresh for [u], then it is α-fresh. Note however that the converse is not true: [a] is α-fresh for [[⟨a;a⟩]], and yet [a∈⌊[⟨a;a⟩]⌋=[a]]. *)
  Lemma αfresh_support a u : a # u -> a #α u.
  Proof.
    unfold fresh__α in *;induction u as [|l u];simpl;auto.
    rewrite 𝗙_cons.
    intro h;rewrite IHu,prod_unit_r.
    - apply αfresh_letter.
      intro I;apply h,In_support_list.
      exists l;simpl;auto.
    - intro I;apply h,In_support_list.
      apply In_support_list in I as (l'&I'&I).
      exists l';simpl;auto.
  Qed.

  Lemma open_balanced_no_open u a : ~ open a ∈ u -> a ▷ u.
  Proof.
    unfold open_balanced;intros I1;induction u;simpl.
    - reflexivity.
    - simpl in *;simpl_binding.
      rewrite IHu by tauto.
      destruct a0;simpl;unfold_eqX;tauto.
  Qed.

  Lemma close_balanced_no_close u a : ~ close a ∈ u -> a ◁ u.
  Proof.
    unfold close_balanced;intros I1;induction u;simpl.
    - reflexivity.
    - simpl in *;simpl_binding.
      rewrite IHu by tauto.
      destruct a0;simpl;unfold_eqX;tauto.
  Qed.
  
  Lemma balanced_open_close u a : ~ open a ∈ u -> ~ close a ∈ u -> a ⋄ u.
  Proof.
    intros I1 I2;split;[apply open_balanced_no_open|apply close_balanced_no_close];assumption.
  Qed.
  
  (** ** Decomposition properties *)
  (** If [a] is not open-balanced in [u], then there is an unmatched [⟨a] in [u], and therefore a last unmatched [⟨a]. This means that [u] may be factorised as [u1++⟨a::u2], with [a] being balanced in [u2]. *)
  Lemma αfresh_close_split u a : ~ a ▷ u -> exists u1 u2, u = u1 ++ open a :: u2 /\ a ⋄ u2.
  Proof.
    remember ⎢u⎥ as n.
    assert (L:⎢u⎥ <= n) by (rewrite Heqn;reflexivity).
    clear Heqn;revert u L;induction n;intros u.
    - destruct u;simpl;try lia.
      unfold open_balanced,𝗙,prod_binding at 1;simpl;tauto.
    - destruct_eqX u (@nil letter).
      + unfold open_balanced,𝗙,prod_binding at 1;simpl;tauto. 
      + apply not_nil_add in N as (w&[b|b|x]&->).
        * unfold open_balanced in *;rewrite app_length;simpl.
          intro L';assert (L:length  w <= n) by lia;clear L'.
          destruct_eqX a b;[symmetry in E;subst|];simpl.
          -- intros _;exists w,[];split;auto.
             unfold balanced;simpl;tauto.
          -- intros F;destruct (IHn _ L) as (u1&u2&->&B).
             ++ revert F;simpl_binding;lia.
             ++ exists u1,(u2++[open b]).
                rewrite app_ass;simpl;split;auto;destruct B as (B1&B2).
                unfold balanced,close_balanced,open_balanced in *.
                revert F;simpl_binding;rewrite B1,B2;simpl;auto.
        * unfold open_balanced in *.
          rewrite app_length;simpl;intro L';assert (Lw:length  w <= n) by lia;clear L'.
          simpl_binding;destruct_eqX b a;subst;simpl_binding.
          -- intros E; destruct (IHn _ Lw) as (u0&u3&->&B3);auto.
             ++ intro Ew;apply E;lia.
             ++ revert E;simpl_binding;destruct B3 as (C3&D3);rewrite C3,D3;simpl.
                assert (Lu0:⎢u0⎥ <= n) by (rewrite app_length in Lw;simpl in Lw;lia);clear Lw.
                intro;destruct (IHn _ Lu0) as (u1&u2&->&B2);[lia|].
                exists u1,(u2++open a::u3++[close a]).
                repeat rewrite app_ass;simpl;split;auto.
                destruct B2 as (B1&B2);unfold balanced;simpl_binding;rewrite B1,B2,C3,D3;auto.
          -- intros E; destruct (IHn _ Lw) as (u1&u2&->&C3&D3);[lia|].
             exists u1,(u2++[close b]);rewrite app_ass;simpl;split;auto.
             unfold balanced;simpl_binding;rewrite C3,D3;auto. 
        * intros L B;destruct (IHn w) as (u1&u2&->&B').
          ++ rewrite app_length in L;simpl in L;lia.
          ++ revert B;unfold open_balanced;simpl_binding;lia.
          ++ exists u1,(u2++[var x]);rewrite app_ass;simpl;split;auto.
             revert B';unfold balanced;simpl_binding;lia.
  Qed.

  (** Similarly, for closing brackets. *)
  Lemma αfresh_open_split u a : ~ a ◁ u -> exists u1 u2, u = u1 ++ close a :: u2 /\ a ⋄ u1.
  Proof.
    unfold close_balanced;induction u using len_induction;simpl.
    - unfold 𝗙,prod_binding at 1;simpl;tauto.
    - simpl_binding.
      destruct a0 as [b|b|x];simpl;unfold_eqX;simpl;subst.
      + intros L.
        destruct (H l) as (u1&u2&->&B).
        * reflexivity.
        * lia.
        * destruct (H u2) as (v1&v2&->&B').
          -- solve_length.
          -- revert L;simpl_binding;destruct B as (->&->);lia.
          -- exists (open b::u1++close b::v1),v2;simpl;split.
             ++ repeat rewrite app_ass;reflexivity.
             ++ unfold balanced;simpl_binding;destruct B as (->&->),B' as (->&->);simpl;tauto.
      + simpl_nat;intro D;apply H in D as (u1&u2&->&B);[|reflexivity].
        exists (open b::u1),u2;unfold balanced;simpl_binding;destruct B as (->&->);tauto.
      + intros _;exists [],l;simpl;repeat split.
      + simpl_nat;intro D;apply H in D as (u1&u2&->&B);[|reflexivity].
        exists (close b::u1),u2;unfold balanced;simpl_binding;destruct B as (->&->);tauto.
      + simpl_nat;intro D;apply H in D as (u1&u2&->&B);[|reflexivity].
        exists (var x::u1),u2;unfold balanced;simpl_binding;destruct B as (->&->);tauto.
  Qed.
  
  (** This decomposition is unique.*)
  Lemma αfresh_close_split_unique u1 u2 v1 v2 a :
    u1 ++ open a :: u2 = v1 ++ open a :: v2 -> a ⋄ u2 -> a ⋄ v2 -> u1 = v1 /\ u2 = v2.
  Proof.
    intros E B1 B2;levi E.
    - inversion E1;auto.
    - exfalso;inversion E1;subst;clear E E1.
      destruct B2 as (B2&_);apply open_balanced_suffix in B2.
      revert B2;unfold open_balanced;simpl_binding;destruct B1 as (->&->);lia. 
    - exfalso;inversion E1;subst;clear E E1.
      destruct B1 as (B1&_);apply open_balanced_suffix in B1.
      revert B1;unfold open_balanced;simpl_binding;destruct B2 as (->&->);lia.
  Qed.
  
  (** * Alpha-equivalence *)
  (** We write [≡] for the relation defined as follows: 
    - [≡] is transitive, and [[]≡[]];
    - if [u≡v], then [x::u≡x::v] and [u++[x]≡v++[x]];
    - if [b] is α-fresh in [u] and [a] is balanced in [u], then [⟨a::u++[a⟩]] is equivalent to [⟨b::([(a,b)]∙u)++[b⟩]].
   *)
  Inductive αequiv : Equiv word :=
  | αt u v w : u ≡ v -> v ≡ w -> u ≡ w
  | αε : [] ≡ []
  | αr u v l : u ≡ v -> u++[l] ≡ v++[l]
  | αl u v l : u ≡ v -> l::u ≡ l::v
  | αα a b u : b #α u -> a ⋄ u -> ⟨a::u++[a⟩] ≡ ⟨b::([(a,b)]∙u)++[b⟩].
  Hint Constructors αequiv.
  (* begin hide *)
  Global Instance wequiv : Equiv word := αequiv.
  (* end hide *)
  
  (** This is an equivalence relation. *)
  Global Instance αequiv_equivalence : Equivalence equiv.
  Proof.
    split.
    - intro w;induction w using rev_induction;auto.
    - intros u v E;induction E;eauto.
      assert (E: u = [(b,a)]∙([(a,b)]∙u)).
      + rewrite action_compose;symmetry;apply action_invariant,map_eq_id.
        intros x I;repeat setoid_rewrite act_cons;rewrite act_nil;simpl.
        destruct_eqX x a;auto.
        destruct_eqX x b;try simpl_beq;auto.
      + rewrite E at 2;apply αα.
        * apply αfresh_perm;simpl.
          repeat setoid_rewrite act_cons;rewrite act_nil;simpl;simpl_beq;auto.
        * apply balanced_perm;simpl;repeat setoid_rewrite act_cons;rewrite act_nil;simpl;
            simpl_beq;auto;destruct_eqX b a;auto.
    - eauto.
  Qed.

  (** This relation is a congruence. *)
  Lemma αequiv_app_left u v w : u ≡ v -> w++u≡w++v.
  Proof. intro E;induction w;simpl;auto. Qed.
  Lemma αequiv_app_right (u v w : word) : u ≡ v -> u++w≡v++w.
  Proof. 
    intro E;revert w;induction w using rev_induction;simpl;auto.
    + repeat rewrite app_nil_r;auto.
    + repeat rewrite <- app_ass; apply αr;auto.
  Qed.

  Global Instance αequiv_app :
    Proper (equiv ==> equiv ==> equiv) (@app letter).
  Proof.
    intros u1 v1 E1 u2 v2 E2.
    transitivity (u1++v2).
    - apply αequiv_app_left;auto.
    - apply αequiv_app_right;auto.
  Qed.

  (** Equivalent words have the same length. *)
  Lemma αequiv_length u v : u ≡ v -> ⎢u⎥ = ⎢v⎥.
  Proof.
    intro E;induction E;simpl;auto.
    - lia.
    - repeat rewrite app_length;lia.
    - repeat rewrite app_length. setoid_rewrite act_lists_length.
      simpl;lia.
  Qed.

  (** Equivalent words have the same binding power. *)
  Lemma αequiv_binding u v : u ≡ v -> forall a, 𝗙 a u = 𝗙 a v.
  Proof.
    intro E;induction E;intro x;simpl;auto.
    - rewrite IHE,IHE0;reflexivity.
    - repeat rewrite 𝗙_add;rewrite IHE;auto.
    - repeat rewrite 𝗙_cons;rewrite IHE;auto.
    - repeat rewrite 𝗙_cons,𝗙_add.
      rewrite 𝗙_perm;simpl.
      rewrite act_cons,act_nil.
      destruct_eqX b a;subst;destruct_eqX x a;repeat simpl_beq;auto.
      + unfold balanced,fresh__α in *;destruct H0 as (C&D).
        rewrite H;simpl;destruct (𝗙 a u) as ((m,?),n);unfold d_binding in D;simpl in *.
        rewrite C,D;reflexivity.
      + destruct_eqX x b;auto.
        unfold balanced,fresh__α in *;destruct H0 as (C&D).
        rewrite H;simpl;destruct (𝗙 a u) as ((m,?),n);unfold d_binding in D;simpl in *.
        rewrite C,D;reflexivity.
  Qed.

  (** This relation commutes with the action of permutations. *)
  Lemma αequiv_perm u v π : u ≡ v -> π ∙ u ≡ π ∙ v.
  Proof.
    intro E;revert π;induction E;intro π;simpl;eauto.
    - setoid_rewrite act_lists_app;rewrite IHE;reflexivity.
    - setoid_rewrite act_lists_cons;apply αl,IHE.
    - setoid_rewrite act_lists_cons;setoid_rewrite act_lists_app.
      unfold act at 1 3 4 7;simpl.
      unfold act at 3 7;simpl.
      rewrite action_compose.
      replace ((π ++ [(a, b)]) ∙ u) with (([(π ∙ a, π ∙ b)] ++ π) ∙ u).
      + rewrite<-action_compose;apply αα.
        * apply αfresh_perm;rewrite inverse_comp_l;auto.
        * apply balanced_perm;rewrite inverse_comp_l;auto.
      + apply equiv_perm_act;auto.
        intro x;simpl;rewrite <- action_compose.
        repeat rewrite act_cons;rewrite act_nil.
        destruct_eqX x a;auto.
        destruct_eqX x b;auto.
        * rewrite <- act_bij with (p:=π) in N.
          apply eqX_false in N;setoid_rewrite N;auto.
        * rewrite <- act_bij with (p:=π) in N.
          rewrite <- act_bij with (p:=π) in N0.
          apply eqX_false in N;setoid_rewrite N;auto.
          apply eqX_false in N0;setoid_rewrite N0;auto.
  Qed.

End s.
Hint Transparent ε.

Notation " ⟨ a " := (open a) (at level 0).
Notation " a ⟩ " := (close a) (at level 0).
Infix " ⋅ " := prod_binding (at level 50).
Infix " #α " := fresh__α (at level 30).
Infix " ⋄ " := balanced (at level 20).
Infix " ◁ " := close_balanced (at level 20).
Infix " ▷ " := open_balanced (at level 20).

(* begin hide *)
Ltac simpl_words :=
  try discriminate;
  match goal with
  | [h: [] = _ ++ _ :: _ |- _ ] => apply app_cons_not_nil in h;tauto
  | [h: _ ++ _ :: _ = [] |- _ ] => symmetry in h;apply app_cons_not_nil in h;tauto
  | [h: _ ++[close _] = _ ++[close _] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    inversion h';subst;clear h'
  | [h: _ ++[open _] = _ ++[open _] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    inversion h';subst;clear h'
  | [h: _ ++[var _] = _ ++[var _] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    inversion h';subst;clear h'
  | [h: _ ++ [_] = _ ++ [_] |- _ ] =>
    let h' := fresh "h" in
    apply app_inj_tail in h as (h,h');
    try discriminate
  end.
Ltac simpl_binding :=
  repeat (simpl;
          rewrite 𝗙_perm
          || rewrite 𝗳_perm
          || rewrite 𝗙_singl
          || rewrite 𝗙_cons
          || rewrite 𝗙_add
          || rewrite 𝗙_app
          || rewrite c_binding_prod
          || rewrite d_binding_prod
          || rewrite d_binding_simpl
          || (replace (d_binding ε) with 0 by reflexivity)
          || (replace (c_binding ε) with 0 by reflexivity)
          || simpl_beq).
Tactic Notation "simpl_binding" "in" hyp(h) :=
  repeat (rewrite 𝗙_perm in h)
  || (rewrite 𝗳_perm in h)
  || (rewrite 𝗙_singl in h)
  || (rewrite 𝗙_cons in h)
  || (rewrite 𝗙_add in h)
  || (rewrite 𝗙_app in h)
  || (rewrite c_binding_prod in h)
  || (rewrite d_binding_prod in h)
  || (rewrite d_binding_simpl in h)
  || simpl_beq
  || (simpl in h).
Tactic Notation "simpl_binding" "in" "*" :=
  repeat (rewrite 𝗙_perm in * )
  || (rewrite 𝗳_perm in * )
  || (rewrite 𝗙_singl in * )
  || (rewrite 𝗙_cons in * )
  || (rewrite 𝗙_add in * )
  || (rewrite 𝗙_app in * )
  || (rewrite c_binding_prod in * )
  || (rewrite d_binding_prod in * )
  || (rewrite d_binding_simpl in * )
  || simpl_beq
  || (simpl in * ).
Hint Constructors αequiv.
(* end hide *)
